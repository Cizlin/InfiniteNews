// .jsw files enable you to write functions that run on the server side
// Test any backend function by clicking the "Play" button on the left side of the code panel
// About testing backend functions: https://support.wix.com/en/article/velo-testing-your-backend-functions

import wixFetch from 'wix-fetch';
import wixData from 'wix-data';
import {createSecret, updateSecret, getSecret, listSecretInfo} from 'wix-secrets-backend';
import { mediaManager } from 'wix-media-backend';
import * as KeyConstants from 'public/KeyConstants.js';
import * as Waypoint from 'backend/WaypointBackendFunctions.jsw';

//#region Constants
const API_URL_BASE = "https://cryptum.halodotapi.com";
const API_KEY = "HaloDotAPIKey";
const API_VERSION = "2.3-alpha";

const PLACEHOLDER_IMAGE_URL = "wix:image://v1/ee59cf_76d024fd4c2a4cab80bda937a1e1c926~mv2.png/Placeholder%20Image.png#originWidth=275&originHeight=183";

export const XUID_KEY = "Xuid";

// The ITEM_TYPES constant is used to identify which type of item is being processed.
const ITEM_TYPES = {
	core: "core",
	kit: "kit",
	item: "item",
	attachment: "attachment"
};

const WAYPOINT_URL_BASE_PROGRESSION = "https://gamecms-hacs-origin.svc.halowaypoint.com/hi/Progression/file/";
const WAYPOINT_URL_BASE_IMAGE = "https://gamecms-hacs-origin.svc.halowaypoint.com/hi/images/file/"
const WAYPOINT_URL_BASE_WAYPOINT = "https://gamecms-hacs-origin.svc.halowaypoint.com/hi/waypoint/file/";
const WAYPOINT_URL_GUIDE = "https://gamecms-hacs-origin.svc.halowaypoint.com/hi/Progression/guide/xo";

// If a customization category has cores, its key will be included in this array.
export const HAS_CORE_ARRAY = [KeyConstants.ARMOR_KEY, KeyConstants.ARMOR_ATTACHMENT_KEY, KeyConstants.WEAPON_KEY, KeyConstants.VEHICLE_KEY];

// If a customization type is cross-core, it will be included in an array keyed by the customization category.
// Only keys listed in the HAS_CORE_ARRAY should be used here.
// Also, the reason we include Core types themselves is because they aren't sorted into core-specific folders in the media files.
export const IS_CROSS_CORE_ARRAY_DICT = {
	[KeyConstants.ARMOR_KEY]: [KeyConstants.ARMOR_CORE_KEY, KeyConstants.ARMOR_EMBLEM_KEY, KeyConstants.ARMOR_EFFECT_KEY, KeyConstants.ARMOR_MYTHIC_EFFECT_SET_KEY],
	[KeyConstants.ARMOR_ATTACHMENT_KEY]: [],
	[KeyConstants.WEAPON_KEY]: [KeyConstants.WEAPON_CORE_KEY, KeyConstants.WEAPON_CHARM_KEY, KeyConstants.WEAPON_EMBLEM_KEY, KeyConstants.WEAPON_KILL_EFFECT_KEY],
	[KeyConstants.VEHICLE_KEY]: [KeyConstants.VEHICLE_CORE_KEY, KeyConstants.VEHICLE_EMBLEM_KEY]
}

// This dictionary contains the high-level folders for each category within Customization Images.
const CUSTOMIZATION_CATEGORY_FOLDER_DICT = {
	[KeyConstants.ARMOR_KEY]: "Armor Customization",
	[KeyConstants.ARMOR_ATTACHMENT_KEY]: "Armor Customization",
	[KeyConstants.WEAPON_KEY]: "Weapon Customization",
	[KeyConstants.VEHICLE_KEY]: "Vehicle Customization",
	[KeyConstants.BODY_AND_AI_KEY]: "Body & AI Customization",
	[KeyConstants.SPARTAN_ID_KEY]: "Spartan ID Customization",
	[KeyConstants.CONSUMABLES_KEY]: "Consumables",
	[KeyConstants.SHOP_KEY]: "Shop"
}

// This dictionary contains the folders for each customization type within the customization category folders.
const CUSTOMIZATION_TYPE_FOLDER_DICT = {
	[KeyConstants.ARMOR_KEY]: {
		[KeyConstants.ARMOR_CORE_KEY]: "Armor Cores",
		[KeyConstants.ARMOR_KIT_KEY]: "Armor Kits",
		[KeyConstants.ARMOR_COATING_KEY]: "Armor Coatings",
		[KeyConstants.ARMOR_HELMET_KEY]: "Helmets",
		[KeyConstants.ARMOR_VISOR_KEY]: "Visors",
		[KeyConstants.ARMOR_CHEST_KEY]: "Chests",
		[KeyConstants.ARMOR_LEFT_SHOULDER_PAD_KEY]: "Left Shoulder Pads",
		[KeyConstants.ARMOR_RIGHT_SHOULDER_PAD_KEY]: "Right Shoulder Pads",
		[KeyConstants.ARMOR_GLOVES_KEY]: "Gloves",
		[KeyConstants.ARMOR_WRIST_KEY]: "Wrists",
		[KeyConstants.ARMOR_UTILITY_KEY]: "Utilities",
		[KeyConstants.ARMOR_KNEE_PADS_KEY]: "Knee Pads",
		[KeyConstants.ARMOR_EMBLEM_KEY]: "Armor Emblems",
		[KeyConstants.ARMOR_EFFECT_KEY]: "Armor Effects",
		[KeyConstants.ARMOR_MYTHIC_EFFECT_SET_KEY]: "Mythic Effect Sets"
	},
	[KeyConstants.ARMOR_ATTACHMENT_KEY]: {
		[KeyConstants.ARMOR_HELMET_ATTACHMENT_KEY]: "Armor Attachments"
	},
	[KeyConstants.WEAPON_KEY]: {
		[KeyConstants.WEAPON_CORE_KEY]: "Weapon Cores",
		[KeyConstants.WEAPON_KIT_KEY]: "Weapon Kits",
		[KeyConstants.WEAPON_COATING_KEY]: "Weapon Coatings",
		[KeyConstants.WEAPON_MODEL_KEY]: "Weapon Models",
		[KeyConstants.WEAPON_CHARM_KEY]: "Charms",
		[KeyConstants.WEAPON_EMBLEM_KEY]: "Weapon Emblems",
		[KeyConstants.WEAPON_KILL_EFFECT_KEY]: "Kill Effects"
	},
	[KeyConstants.VEHICLE_KEY]: {
		[KeyConstants.VEHICLE_CORE_KEY]: "Vehicle Cores",
		[KeyConstants.VEHICLE_COATING_KEY]: "Vehicle Coatings",
		[KeyConstants.VEHICLE_MODEL_KEY]: "Vehicle Models",
		[KeyConstants.VEHICLE_EMBLEM_KEY]: "Vehicle Emblems"
	},
	[KeyConstants.BODY_AND_AI_KEY]: {
		[KeyConstants.BODY_AND_AI_MODEL]: "AI Models",
		[KeyConstants.BODY_AND_AI_COLOR]: "AI Colors"
	},
	[KeyConstants.SPARTAN_ID_KEY]: {
		[KeyConstants.SPARTAN_ID_NAMEPLATE_KEY]: "Nameplates",
		[KeyConstants.SPARTAN_ID_BACKDROP_KEY]: "Backdrops",
		[KeyConstants.SPARTAN_ID_STANCE_KEY]: "Stances"
	},
	[KeyConstants.SHOP_KEY]: {
		[KeyConstants.SHOP_DAILY]: "Daily",
		[KeyConstants.SHOP_WEEKLY]: "Weekly",
		[KeyConstants.SHOP_INDEFINITE]: "Indefinite",
		[KeyConstants.SHOP_HCS]: "HCS"
	}
}

export const CUSTOMIZATION_WAYPOINT_TO_SITE_KEYS = {
	[KeyConstants.ARMOR_KEY]: {
		"ArmorCore": KeyConstants.ARMOR_CORE_KEY,
		"ArmorTheme": KeyConstants.ARMOR_KIT_KEY,
		"ArmorCoating": KeyConstants.ARMOR_COATING_KEY,
		"ArmorHelmet": KeyConstants.ARMOR_HELMET_KEY,
		"ArmorVisor": KeyConstants.ARMOR_VISOR_KEY,
		"ArmorChestAttachment": KeyConstants.ARMOR_CHEST_KEY,
		"ArmorLeftShoulderPad": KeyConstants.ARMOR_LEFT_SHOULDER_PAD_KEY,
		"ArmorRightShoulderPad": KeyConstants.ARMOR_RIGHT_SHOULDER_PAD_KEY,
		"ArmorGlove": KeyConstants.ARMOR_GLOVES_KEY,
		"ArmorWristAttachment": KeyConstants.ARMOR_WRIST_KEY,
		"ArmorHipAttachment": KeyConstants.ARMOR_UTILITY_KEY,
		"ArmorKneePad": KeyConstants.ARMOR_KNEE_PADS_KEY,
		"ArmorEmblem": KeyConstants.ARMOR_EMBLEM_KEY,
		"ArmorFx": KeyConstants.ARMOR_EFFECT_KEY,
		"ArmorMythicFx": KeyConstants.ARMOR_MYTHIC_EFFECT_SET_KEY
	},
	[KeyConstants.ARMOR_ATTACHMENT_KEY]: {
		"ArmorHelmetAttachment": KeyConstants.ARMOR_HELMET_ATTACHMENT_KEY
	},
	[KeyConstants.WEAPON_KEY]: {
		"WeaponCore": KeyConstants.WEAPON_CORE_KEY,
		"WeaponTheme": KeyConstants.WEAPON_KIT_KEY,
		"WeaponCoating": KeyConstants.WEAPON_COATING_KEY,
		"WeaponAlternateGeometryRegion": KeyConstants.WEAPON_MODEL_KEY,
		"WeaponCharm": KeyConstants.WEAPON_CHARM_KEY,
		"WeaponEmblem": KeyConstants.WEAPON_EMBLEM_KEY,
		"WeaponDeathFx": KeyConstants.WEAPON_KILL_EFFECT_KEY
	},
	[KeyConstants.VEHICLE_KEY]: {
		"VehicleCore": KeyConstants.VEHICLE_CORE_KEY,
		"VehicleCoating": KeyConstants.VEHICLE_COATING_KEY,
		"VehicleAlternateGeometryRegion": KeyConstants.VEHICLE_MODEL_KEY,
		"VehicleEmblem": KeyConstants.VEHICLE_EMBLEM_KEY
	},
	[KeyConstants.BODY_AND_AI_KEY]: {
		"AiModel": KeyConstants.BODY_AND_AI_MODEL,
		"AiColor": KeyConstants.BODY_AND_AI_COLOR
	},
	[KeyConstants.SPARTAN_ID_KEY]: {
		"SpartanEmblem": KeyConstants.SPARTAN_ID_NAMEPLATE_KEY,
		"SpartanBackdropImage": KeyConstants.SPARTAN_ID_BACKDROP_KEY,
		"SpartanActionPose": KeyConstants.SPARTAN_ID_STANCE_KEY
	},
	[KeyConstants.SHOP_KEY]: {
		"Daily": KeyConstants.SHOP_DAILY,
		"Weekly": KeyConstants.SHOP_WEEKLY,
		"": KeyConstants.SHOP_INDEFINITE,
		"HCS": KeyConstants.SHOP_HCS // This needs to be supplied manually when querying this JSON structure. Does not come directly from Waypoint like the others.
	}
}

export const CUSTOMIZATION_CATEGORY_SPECIFIC_VARS = {
	[KeyConstants.ARMOR_KEY]: {
		"SocketDb": KeyConstants.ARMOR_SOCKET_DB,
		"SocketNameField": "name",
		"CoreDb": KeyConstants.ARMOR_CORE_DB,
		"CoreNameField": "name",
		"CustomizationDb": KeyConstants.ARMOR_CUSTOMIZATION_DB,
		"CustomizationNameField": "itemName",
		"CustomizationSocketReferenceField": KeyConstants.ARMOR_SOCKET_REFERENCE_FIELD,
		"CustomizationCoreReferenceField": KeyConstants.ARMOR_CORE_REFERENCE_FIELD,
		"CustomizationImageField": "image",
		"CustomizationQualityReferenceField": "qualityReference",
		"CustomizationLoreField": "flavorText",
		"CustomizationManufacturerReferenceField": "manufacturerReference",
		"CustomizationReleaseReferenceField": "releaseReference",
		"CustomizationSourceField": "source",
		"CustomizationAttachmentReferenceField": "ArmorCustomizationAttachments"
	},

	[KeyConstants.ARMOR_ATTACHMENT_KEY]: {
		"CustomizationDb": KeyConstants.ARMOR_CUSTOMIZATION_ATTACHMENTS_DB,
		"CustomizationNameField": "itemName",
		"CustomizationImageField": "image",
		"CustomizationQualityReferenceField": "qualityReference",
		"CustomizationLoreField": "flavorText",
		"CustomizationManufacturerReferenceField": "manufacturerReference",
		"CustomizationReleaseReferenceField": "releaseReference",
		"CustomizationSourceField": "source",
		"ParentKey": KeyConstants.ARMOR_KEY
	},

	[KeyConstants.WEAPON_KEY]: {
		"SocketDb": KeyConstants.WEAPON_SOCKET_DB,
		"SocketNameField": "name",
		"CoreDb": KeyConstants.WEAPON_CORE_DB,
		"CoreNameField": "name",
		"CustomizationDb": KeyConstants.WEAPON_CUSTOMIZATION_DB,
		"CustomizationNameField": "itemName",
		"CustomizationSocketReferenceField": KeyConstants.WEAPON_SOCKET_REFERENCE_FIELD,
		"CustomizationCoreReferenceField": KeyConstants.WEAPON_CORE_REFERENCE_FIELD,
		"CustomizationImageField": "image",
		"CustomizationQualityReferenceField": "qualityReference",
		"CustomizationLoreField": "flavorText",
		"CustomizationManufacturerReferenceField": "manufacturerReference",
		"CustomizationReleaseReferenceField": "releaseReference",
		"CustomizationSourceField": "source"
	},

	[KeyConstants.VEHICLE_KEY]: {
		"SocketDb": KeyConstants.VEHICLE_SOCKET_DB,
		"SocketNameField": "name",
		"CoreDb": KeyConstants.VEHICLE_CORE_DB,
		"CoreNameField": "name",
		"CustomizationDb": KeyConstants.VEHICLE_CUSTOMIZATION_DB,
		"CustomizationNameField": "itemName",
		"CustomizationSocketReferenceField": KeyConstants.VEHICLE_SOCKET_REFERENCE_FIELD,
		"CustomizationCoreReferenceField": KeyConstants.VEHICLE_CORE_REFERENCE_FIELD,
		"CustomizationImageField": "image",
		"CustomizationQualityReferenceField": "qualityReference",
		"CustomizationLoreField": "flavorText",
		"CustomizationManufacturerReferenceField": "manufacturerReference",
		"CustomizationReleaseReferenceField": "releaseReference",
		"CustomizationSourceField": "source"
	},

	[KeyConstants.BODY_AND_AI_KEY]: {
		"SocketDb": KeyConstants.BODY_AND_AI_SOCKET_DB,
		"SocketNameField": "name",
		"CustomizationDb": KeyConstants.BODY_AND_AI_CUSTOMIZATION_DB,
		"CustomizationNameField": "itemName",
		"CustomizationSocketReferenceField": KeyConstants.BODY_AND_AI_SOCKET_REFERENCE_FIELD,
		"CustomizationImageField": "image",
		"CustomizationQualityReferenceField": "qualityReference",
		"CustomizationLoreField": "flavorText",
		"CustomizationManufacturerReferenceField": "manufacturerReference",
		"CustomizationReleaseReferenceField": "releaseReference",
		"CustomizationSourceField": "source"
	},

	[KeyConstants.SPARTAN_ID_KEY]: {
		"SocketDb": KeyConstants.SPARTAN_ID_SOCKET_DB,
		"SocketNameField": "name",
		"CustomizationDb": KeyConstants.SPARTAN_ID_CUSTOMIZATION_DB,
		"CustomizationNameField": "itemName",
		"CustomizationSocketReferenceField": KeyConstants.SPARTAN_ID_SOCKET_REFERENCE_FIELD,
		"CustomizationImageField": "image",
		"CustomizationQualityReferenceField": "qualityReference",
		"CustomizationLoreField": "flavorText",
		"CustomizationManufacturerReferenceField": "manufacturerReference",
		"CustomizationReleaseReferenceField": "releaseReference",
		"CustomizationSourceField": "source"
	}
};

const CORE_CATEGORY_SPECIFIC_VARS = {
	[KeyConstants.ARMOR_KEY]: {
		"SocketDb": KeyConstants.ARMOR_SOCKET_DB,
		"SocketNameField": "name",
		"CoreDb": KeyConstants.ARMOR_CORE_DB,
		"CoreNameField": "name",
		"CoreImageField": "image",
		"CoreQualityReferenceField": "qualityReference",
		"CoreLoreField": "lore",
		"CoreManufacturerReferenceField": "manufacturerReference",
		"CoreReleaseReferenceField": "releaseReference",
		"CoreSourceField": "source"
	},

	[KeyConstants.WEAPON_KEY]: {
		"SocketDb": KeyConstants.WEAPON_SOCKET_DB,
		"SocketNameField": "name",
		"CoreDb": KeyConstants.WEAPON_CORE_DB,
		"CoreNameField": "name",
		"CoreImageField": "image",
		"CoreQualityReferenceField": "qualityReference",
		"CoreLoreField": "lore",
		"CoreManufacturerReferenceField": "manufacturerReference",
		"CoreReleaseReferenceField": "releaseReference",
		"CoreSourceField": "source"
	},

	[KeyConstants.VEHICLE_KEY]: {
		"SocketDb": KeyConstants.VEHICLE_SOCKET_DB,
		"SocketNameField": "name",
		"CoreDb": KeyConstants.VEHICLE_CORE_DB,
		"CoreNameField": "name",
		"CoreImageField": "image",
		"CoreQualityReferenceField": "qualityReference",
		"CoreLoreField": "lore",
		"CoreManufacturerReferenceField": "manufacturerReference",
		"CoreReleaseReferenceField": "releaseReference",
		"CoreSourceField": "source"
	}
};

// This is a bit special since we also have a true/false value telling whether the customization group type has attachments or not.
const CUSTOMIZATION_WAYPOINT_GROUP_TYPES = {
	[KeyConstants.ARMOR_KEY]: {
		"Coatings": false,
		"Helmets": true,
		"Visors": false,
		"LeftShoulderPads": false,
		"RightShoulderPads": false,
		"Gloves": false,
		"KneePads": false,
		"ChestAttachments": false,
		"WristAttachments": false,
		"HipAttachments": false,
		"Emblems": false,
		"ArmorFx": false,
		"MythicFx": false
	},
	[KeyConstants.WEAPON_KEY]: {
		"Coatings": false,
		"StatTrackers": false,
		"WeaponCharms": false,
		"AmmoCounterColors": false,
		"DeathFx": false,
		"Emblems": false,
		"AlternateGeometryRegions": false
	},
	[KeyConstants.VEHICLE_KEY]: {
		"Coatings": false,
		"Emblems": false,
		"VehicleFx": false,
		"VehicleCharms": false,
		"Horns": false,
		"AlternateGeometryRegions": false
	},
	[KeyConstants.BODY_AND_AI_KEY]: {
		"Models": false,
		"Colors": false
	}
};

const CUSTOMIZATION_WAYPOINT_GROUP_TYPE_TO_WAYPOINT_TYPE = {
	[KeyConstants.ARMOR_KEY]: {
		"Coatings": "ArmorCoating",
		"Helmets": "ArmorHelmet",
		"Visors": "ArmorVisor",
		"LeftShoulderPads": "ArmorLeftShoulderPad",
		"RightShoulderPads": "ArmorRightShoulderPad",
		"Gloves": "ArmorGlove",
		"KneePads": "ArmorKneePad",
		"ChestAttachments": "ArmorChestAttachment",
		"WristAttachments": "ArmorWristAttachment",
		"HipAttachments": "ArmorHipAttachment",
		"Emblems": "ArmorEmblem",
		"ArmorFx": "ArmorFx",
		"MythicFx": "ArmorMythicFx"
	},
	[KeyConstants.WEAPON_KEY]: {
		"Coatings": "WeaponCoating",
		"StatTrackers": "WeaponStatTracker",
		"WeaponCharms": "WeaponCharm",
		"AmmoCounterColors": "WeaponAmmoCounterColor",
		"DeathFx": "WeaponDeathFx",
		"Emblems": "WeaponEmblem",
		"AlternateGeometryRegions": "WeaponAlternateGeometryRegion"
	},
	[KeyConstants.VEHICLE_KEY]: {
		"Coatings": "VehicleCoating",
		"Emblems": "VehicleEmblem",
		"VehicleFx": "VehicleFx",
		"VehicleCharms": "VehicleCharm",
		"Horns": "VehicleHorn",
		"AlternateGeometryRegions": "VehicleAlternateGeometryRegion"
	},
	[KeyConstants.BODY_AND_AI_KEY]: {
		"Models": "AiModel",
		"Colors": "AiColor"
	}
};

// If a Customization Category has a type with attachments, it can be referenced here.
const CUSTOMIZATION_TYPES_WITH_ATTACHMENTS = {
	[KeyConstants.ARMOR_KEY]: [KeyConstants.ARMOR_HELMET_KEY]
};
//#endregion

// Retrieves the Spartan Token, either from HaloDotAPI or the SpartanToken secret with the following value format:
/* 
	{
		"Token": [SpartanToken],
		"Expiration": [ExpirationDatetime]
	}
*/
export async function getSpartanToken(refresh = true) { // The refresh argument is true by default and forces a new SpartanToken to be retrieved from the API.
	const SPARTAN_TOKEN_KEY = "SpartanToken";

	let spartanTokenJson; // This variable will contain the Json from our stored secret. 
	let tokenNeededFromApi = false; // If true, we need to get a new token from the API.
	let spartanToken = null; // This variable stores the return value for our
	
	// If it exists and hasn't expired, we can just return the token. If it has expired, we need to get a new one.
	try {
		spartanTokenJson = JSON.parse(await getSecret(SPARTAN_TOKEN_KEY));
		let expirationDatetime = new Date(spartanTokenJson.Expiration); // The expiration datetime is stored within the JSON.
		let currentDatetimePlusTenMin = new Date((new Date()).getTime() + 60000); // We add 10 minute to the current datetime to make sure the expiration isn't coming immediately.

		// If the datetime is too close to or past the expiration, we need to grab a new token.
		if (currentDatetimePlusTenMin >= expirationDatetime) {
			tokenNeededFromApi = true;
		}
		else { // Our existing token is still good. Let's just use it.
			spartanToken = spartanTokenJson.Token;
		}
	}
	catch (exception) {
		// Token didn't exist most likely. Need to get it from the API.
		console.warn(exception);
		tokenNeededFromApi = true;
	}
	
	//console.log("Token flag value: " + tokenNeededFromApi);

	if (tokenNeededFromApi || refresh) {
		// The API expects a post request for a Spartan token. The payload is JSON including the identifier, env, and version. The below are for Halo Infinite.
		let body = {
			"identifier": "hi",
			"env": "prod",
			"version": 4
		}

		// We use the API Key stored in our secrets to query the API.
		const apiKey = await getSecret(API_KEY);

		// Query the API. Note that the Authorization, Content-Type, and Cryptum-API-Version must all be provided in the headers.
		await wixFetch
			.fetch(API_URL_BASE + "/partners/tooling/waypoint/spartan-token", {
				"method": "post",
				"headers": {
					"Authorization": apiKey,
					"Content-Type": "application/json",
					"Cryptum-API-Version": API_VERSION
				},
				"body": JSON.stringify(body) // Body must be a string.
			})
			.then( (httpResponse) => {
				if (httpResponse.ok) {
					return httpResponse.json();
				} else {
					return Promise.reject("Fetch did not succeed. Got HTTP Response: " + httpResponse.status);
				}
			} )
			.then((json) => {
				// Now that we have our Spartan Token, we need to add it to the Secrets so we don't always have to perform this query.
				let secret = {
					name: SPARTAN_TOKEN_KEY,
					value: JSON.stringify({
						"Token": json.data.token,
						"Expiration": json.data.expiration.date
					}),
					description: "Value needs to be parsed into JSON. The token is stored in Token, and the expiration date is stored in Expiration."
				};

				//console.log("Found Spartan Token, adding to secrets...");

				listSecretInfo() // The Spartan Token Key might exist, in which case we need to update based on the ID.
					.then((secrets) => {
						let spartanTokenId = null;
						secrets.forEach(element => {
							if (element.name == SPARTAN_TOKEN_KEY) {
								//console.log("Found Spartan Token");
								//console.log("Returning " + element.id);
								spartanTokenId = element.id;
							}
						});

						if (spartanTokenId) {
							updateSecret(spartanTokenId, secret)
								.catch((error) => {
									console.error(error);
								});
						}
						else {
							createSecret(secret)
								.catch((error) => {
									console.error(error);
								});
						}
					})
					.catch((error) => {
						console.error(error);
					});
				
				spartanToken = json.data.token;
			})
			.catch(err => {
				console.error(err);
			});
	}

	return spartanToken;
}

// Retrieves the 343 Clearance from HaloDotAPI.
export async function getClearance() {
	// The API expects a post request for the clearance value. The payload is JSON including the identifier and env. The below are for Halo Infinite.
	let body = {
		"identifier": "hi",
		"env": "prod"
	}

	// We use the API Key stored in our secrets to query the API.
	const apiKey = await getSecret(API_KEY);

	// Query the API. Note that the Authorization, Content-Type, and Cryptum-API-Version must all be provided.
	return wixFetch
		.fetch(API_URL_BASE + "/partners/tooling/waypoint/clearance", {
			"method": "post",
			"headers": {
				"Authorization": apiKey,
				"Content-Type": "application/json",
				"Cryptum-API-Version": API_VERSION
			},
			"body": JSON.stringify(body)
		})
		.then( (httpResponse) => {
			if (httpResponse.ok) {
				return httpResponse.json();
			} else {
				return Promise.reject("Fetch did not succeed. Got HTTP Response: " + httpResponse.status);
			}
		} )
		.then((json) => {
			return json.data.id;
		})
		.catch(err => {
			console.error(err);
		});
}

// Combines the Spartan Token and Clearance into a single JSON header object, along with other necessary headers.
export async function makeWaypointHeaders() {
	let spartanToken = await getSpartanToken(false);
	let clearance = await getClearance();

	return {
		"X-343-Authorization-Spartan": spartanToken,
		"343-Clearance": clearance,
		"accept-language": "en-US,en;q=0.9"
	}
}

// Retrieves an item's JSON file from the Waypoint API.
export async function getCustomizationItem(headers, path) {
	// Query the Waypoint API.
	let retry = true;
	let waypointJson = {};

	while (retry) {
		waypointJson = await wixFetch.fetch(WAYPOINT_URL_BASE_PROGRESSION + path, {
				"method": "get",
				"headers": headers
			})
			.then( (httpResponse) => {
				if (httpResponse.ok) {
					retry = false;
					return httpResponse.json();
				} 
				else { // We want to retry once with updated headers if we got an error.
					console.warn("Headers did not work. Got HTTP response " + httpResponse.status + ": " + httpResponse.statusText + " when trying to retrieve from " + httpResponse.url);
					return {};
				}
			} )
			.then((json) => {
				return json;
			})
			.catch(err => {
				console.error(err);
				return {};
			});

		if (retry) { // We need to remake the headers, but we do it by adjusting the actual contents of the JSON.
			let spartanToken = await getSpartanToken();
			let clearance = await getClearance();
			
			headers["X-343-Authorization-Spartan"] = spartanToken;
			headers["343-Clearance"] = clearance;

			retry = false; // For now, let's just do a single retry after fixing the headers.
		}
	}

	return waypointJson;
}

// Retrieves the list of Armor Cores from the Waypoint API.
async function getArmorCoreList(headers) {
	// Query the API. Note that the Authorization, Content-Type, and Cryptum-API-Version must all be provided.
	let retry = true;
	let waypointJson = {};

	while (retry) {
		waypointJson = await wixFetch.fetch(WAYPOINT_URL_BASE_WAYPOINT + "armor-core-list.json", {
				"method": "get",
				"headers": headers
			})
			.then( (httpResponse) => {
				if (httpResponse.ok) {
					retry = false;
					return httpResponse.json();
				} 
				else { // We want to retry once with updated headers if we got an error.
					console.warn("Headers did not work. Got HTTP response " + httpResponse.status + ": " + httpResponse.statusText + " when trying to retrieve from " + httpResponse.url);
					return {};
				}
			} )
			.then((json) => {
				return json;
			})
			.catch(err => {
				console.error(err);
				return {};
			});

		if (retry) { // We need to remake the headers, but we do it by adjusting the actual contents of the JSON.
			let spartanToken = await getSpartanToken();
			let clearance = await getClearance();
			
			headers["X-343-Authorization-Spartan"] = spartanToken;
			headers["343-Clearance"] = clearance;

			retry = false; // For now, let's just do a single retry after fixing the headers.
		}
	}

	return waypointJson;
}

// Retrieves a list of paths to owned Cores from the Waypoint API matching the customizationCategory. Without a way to see all the cores available in each section (or view the Spartan ID stuff), this is the best I've got.
async function getCoreList(headers, customizationCategory) {
	const XUID = await getSecret(XUID_KEY);

	let retry = true;
	let inventoryJson = {};

	while (retry) {
		inventoryJson = await wixFetch.fetch("https://economy.svc.halowaypoint.com/hi/players/xuid(" + XUID + ")/inventory", {
				"method": "get",
				"headers": headers
			})
			.then( (httpResponse) => {
				if (httpResponse.ok) {
					retry = false;
					return httpResponse.json();
				} 
				else { // We want to retry once with updated headers if we got an error.
					console.warn("Headers did not work. Got HTTP response " + httpResponse.status + ": " + httpResponse.statusText + " when trying to retrieve from " + httpResponse.url);
					return {};
				}
			} )
			.then((json) => {
				return json;
			})
			.catch(err => {
				console.error(err);
				return {};
			});
		
		if (retry) { // We need to remake the headers, but we do it by adjusting the actual contents of the JSON.
			let spartanToken = await getSpartanToken();
			let clearance = await getClearance();
			
			headers["X-343-Authorization-Spartan"] = spartanToken;
			headers["343-Clearance"] = clearance;

			retry = false; // For now, let's just do a single retry after fixing the headers.
		}
	}
	
	// We have a list of every owned theme and a bunch of other owned items. Cores aren't really included in this, so we have to be clever. Let's get a list of matching themes first.
	let typeToFind = "";
	switch (customizationCategory) {
		case KeyConstants.WEAPON_KEY: 
			typeToFind = "WeaponTheme";
			break;

		case KeyConstants.VEHICLE_KEY:
			typeToFind = "VehicleTheme";
			break;
		
		default:
			throw customizationCategory + " is not an allowed customization category. Exiting.";
	}

	// Time to fetch the themes matching our category
	let themeArray = [];
	inventoryJson.Items.forEach((item) => {
		if (item.ItemType == typeToFind) {
			themeArray.push(item.ItemPath);
		}
	});

	// Now that we have all the themes, we want to visit each one and extract the cores within.
	let corePathArray = [];
	for (let i = 0; i < themeArray.length; ++i) {
		let themeJson = await getCustomizationItem(headers, themeArray[i]);
		let themeParentArray = themeJson.CommonData.ParentPaths;
		for (let j = 0; j < themeParentArray.length; ++j) {
			// If we don't already have this core path, add it now.
			if (!corePathArray.includes(themeParentArray[j].Path)) {
				corePathArray.push(themeParentArray[j].Path);
			}
		}
	}

	// We got the corePaths. Time to return.

	return corePathArray;

}

// This function returns a list of themes for customization categories with no cores (currently can only access Body And AI).
async function getThemeList(headers, customizationCategory) {
	const XUID = await getSecret(XUID_KEY);

	let retry = true;
	let inventoryJson = {};

	while (retry) {
		inventoryJson = await wixFetch.fetch("https://economy.svc.halowaypoint.com/hi/players/xuid(" + XUID + ")/inventory", {
				"method": "get",
				"headers": headers
			})
			.then( (httpResponse) => {
				if (httpResponse.ok) {
					retry = false;
					return httpResponse.json();
				} 
				else { // We want to retry once with updated headers if we got an error.
					console.warn("Headers did not work. Got HTTP response " + httpResponse.status + ": " + httpResponse.statusText + " when trying to retrieve from " + httpResponse.url);
					return {};
				}
			} )
			.then((json) => {
				return json;
			})
			.catch(err => {
				console.error(err);
				return {};
			});
		
		if (retry) { // We need to remake the headers, but we do it by adjusting the actual contents of the JSON.
			let spartanToken = await getSpartanToken();
			let clearance = await getClearance();
			
			headers["X-343-Authorization-Spartan"] = spartanToken;
			headers["343-Clearance"] = clearance;

			retry = false; // For now, let's just do a single retry after fixing the headers.
		}
	}
	

	// We have a list of every owned theme and a bunch of other owned items. Cores aren't really included in this, so we have to be clever. Let's get a list of matching themes first.
	let typeToFind = "";
	switch (customizationCategory) {
		case KeyConstants.BODY_AND_AI_KEY: 
			typeToFind = "AiTheme";
			break;
		
		default:
			throw customizationCategory + " is not an allowed customization category. Exiting.";
	}

	// Time to fetch the themes matching our category. There's probably only one, but you never know.
	let themeArray = [];
	inventoryJson.Items.forEach((item) => {
		if (item.ItemType == typeToFind) {
			themeArray.push(item.ItemPath);
		}
	});

	return themeArray;
}

export async function getSpartanIdPathList(headers) {
	// Query the Waypoint API. This XML is huge, so we can't use the Wix solution sadly.
	var https = require('https');

	let httpOptions = {
		headers: headers
	};

	return new Promise ((resolve, reject) => {
		let request = https.get(WAYPOINT_URL_GUIDE, httpOptions, (response) => {
			let { statusCode } = response;
			console.log(`statusCode: ${statusCode}`)

			let error;

			if (statusCode !== 200) {
				error = new Error('Request Failed.\n' +
					`Status Code: ${statusCode}`);
			}

			if (error) {
				console.error(error.message);
				// consume response data to free up memory
				response.resume();
			}

			// We're expecting XML. This means we want the latin1 encoding, which replaces the legacy binary encoding.
			response.setEncoding('latin1');
			let responseString = '';

			// Get each chunk of text from the response.
			response.on('data', d => {
				responseString += d;
			});

			response.on('end', () => {
				try {
					var waypointJson = JSON.parse(responseString);
					let spartanIdPathArray = [];
					//console.log(waypointJson);
					for (let i = 0; i < waypointJson.Files.length; ++i) {
						if (waypointJson.Files[i].Uri.Path.includes("Spartan") && !waypointJson.Files[i].Uri.Path.includes("/Voices/")) {
							let indexOfSubPath = waypointJson.Files[i].Uri.Path.search("Inventory");
							spartanIdPathArray.push(waypointJson.Files[i].Uri.Path.substring(indexOfSubPath));
						}
					}

					resolve(spartanIdPathArray);
					//var convert = require('xml-js');
					//console.log(responseXml.length);
					//var waypointJson = convert.xml2json(responseXml, {compact: true, spaces: 0});
					//console.log(waypointJson);
				}
				catch (error) {
					reject(`Got error: ${error.message}`)
				}
			})
		});

		request.on('error', error => {
			reject(`Got error: ${error.message}`);
		});

		request.end();
	});
}

// Retrieves an item's JSON file from the Waypoint API. Returns the Wix URL to the stored image. This is returned as a Promise that resolves to the URL on success.
async function addCustomizationImageToMediaManager(headers, waypointPath, mimeType, mediaManagerPath, fileName) {
	var https = require('https');

	let httpOptions = {
		headers: headers
	};

	return new Promise((resolve, reject) => {
		let request = https.get(WAYPOINT_URL_BASE_IMAGE + waypointPath, httpOptions, (response) => {
			let { statusCode } = response;
			console.log(`statusCode: ${statusCode}`)

			let error;

			if (statusCode !== 200) {
				error = new Error('Request Failed.\n' +
					`Status Code: ${statusCode}`);
			}

			if (error) {
				//console.error(error.message);
				// consume response data to free up memory
				response.resume();
			}

			// We're expecting a png to be transferred as singular bytes. This means we want the latin1 encoding, which replaces the legacy binary encoding.
			response.setEncoding('latin1');
			let imageString = '';

			// Get each chunk of bytes from the response.
			response.on('data', d => {
				imageString += d;
			});

			response.on('end', async () => {
				try {
					let imageBuffer = Buffer.from(imageString, 'latin1');

					// Save the image to our desired path and with our desired name.
					if (statusCode == 200) {
						let imageInfo = await mediaManager.upload(mediaManagerPath, imageBuffer, fileName, {
							"mediaOptions": {
								"mimeType": mimeType,
								"mediaType": "image"
							},
							"metadataOptions": {
								"isPrivate": false,
								"isVisitorUpload": false
							}
						});
						resolve(imageInfo.fileUrl);
					}
					else {
						throw "Request failed: Status Code " + statusCode;
					}
				}
				catch (error) {
					console.error("Got error" + error.message + "while trying to upload image for " + fileName + ". Using placeholder image.");
					resolve(PLACEHOLDER_IMAGE_URL);
				}
			})
		});

		request.on('error', error => {
			reject(`Got error: ${error.message}`);
		});

		request.end();
	});
}

// We need to be more efficient, so we're going to generate the entire folder tree all at once, then use the paths in the tree to locate each image.
export async function generateFolderDict() {
	// The folderDict will essentially be a hierarchical listing of the customization images folders. The ID of each folder is stored in _id, except for "/".
	// We will also store the files in this dictionary with the user-readable filename as the key (with . replaced by , since JSON) and the file Name as the value. 
	// Still need to fetch the file URL, but that should be quick. Speed. I am speed.

	console.log("Starting folder dict generation.");
	let folderDict = {  
		"/": { }
	};

	let rootFolderList = await mediaManager.listFolders();
	let parentFolderId = "";
	let customizationImageFolderName = "";
	rootFolderList.forEach((element) => {
		if (element.folderName == "Customization Images") {
			folderDict["/"][element.folderName + "/"] = { "_id": element.folderId }
			parentFolderId = element.folderId;
			customizationImageFolderName = element.folderName;
		}
	});

	// Now that we're in the Customization Images folder, we need to get the list of folders within it.
	let customizationImagesFolderList = await mediaManager.listFolders({parentFolderId: parentFolderId});
	let customizationImagesFileList = await mediaManager.listFiles({parentFolderId: parentFolderId}, null, {limit: 500});
	customizationImagesFileList.forEach((file) => {
		folderDict["/"][customizationImageFolderName + "/"][file.originalFileName.replace(/\./g, ",")] = file.fileName;
	});

	let customizationCategoryFolderName;

	for (let i = 0; i < customizationImagesFolderList.length; i++) {
		let element = customizationImagesFolderList[i];
		folderDict["/"][customizationImageFolderName + "/"][element.folderName + "/"] = { "_id": element.folderId }
		parentFolderId = element.folderId;
		customizationCategoryFolderName = element.folderName;
		
		// For each of these category folders, we need to get the folders within.
		let customizationCategoryFolderList = await mediaManager.listFolders({parentFolderId: parentFolderId});
		let customizationCategoryFileList = await mediaManager.listFiles({parentFolderId: parentFolderId}, null, {limit: 500});
		customizationCategoryFileList.forEach((file) => {
			folderDict["/"][customizationImageFolderName + "/"][customizationCategoryFolderName + "/"][file.originalFileName.replace(/\./g, ",")] = file.fileName;
		});

		let customizationTypeFolderName;
		for (let j = 0; j < customizationCategoryFolderList.length; j++) {
			let typeElement = customizationCategoryFolderList[j];
			folderDict["/"][customizationImageFolderName + "/"][customizationCategoryFolderName + "/"][typeElement.folderName + "/"] = { "_id": typeElement.folderId }
			parentFolderId = typeElement.folderId;
			customizationTypeFolderName = typeElement.folderName;
			
			// Same for the type folders.
			let customizationTypeFolderList = await mediaManager.listFolders({parentFolderId: parentFolderId});
			let customizationTypeFileList = await mediaManager.listFiles({parentFolderId: parentFolderId}, null, {limit: 500});
			customizationTypeFileList.forEach((file) => {
				folderDict["/"][customizationImageFolderName + "/"][customizationCategoryFolderName + "/"][customizationTypeFolderName + "/"][file.originalFileName.replace(/\./g, ",")] = file.fileName;
			});
			
			let customizationCoreFolderName;
			for (let k = 0; k < customizationTypeFolderList.length; k++) {
				let coreElement = customizationTypeFolderList[k];
				// Big line below. Terribly sorry.
				folderDict["/"][customizationImageFolderName + "/"][customizationCategoryFolderName + "/"][customizationTypeFolderName + "/"][coreElement.folderName + "/"] = { "_id": coreElement.folderId }
				parentFolderId = coreElement.folderId;
				customizationCoreFolderName = coreElement.folderName;
			
				// And for attachments, the parent customization type...
				let customizationCoreFolderList = await mediaManager.listFolders({parentFolderId: parentFolderId});
				let customizationCoreFileList = await mediaManager.listFiles({parentFolderId: parentFolderId}, null, {limit: 500});
				customizationCoreFileList.forEach((file) => {
					folderDict["/"][customizationImageFolderName + "/"][customizationCategoryFolderName + "/"][customizationTypeFolderName + "/"][customizationCoreFolderName + "/"][file.originalFileName.replace(/\./g, ",")] = file.fileName;
				});

				for (let l = 0; l < customizationCoreFolderList.length; l++) {
					let parentTypeElement = customizationCoreFolderList[l];
					// This is actually insane at this point. Beware the giant AF line below!
					folderDict["/"][customizationImageFolderName + "/"][customizationCategoryFolderName + "/"][customizationTypeFolderName + "/"][customizationCoreFolderName + "/"][parentTypeElement.folderName + "/"] = { "_id": parentTypeElement.folderId }
					
					let customizationParentTypeFileList = await mediaManager.listFiles({parentFolderId: parentTypeElement.folderId})
					customizationParentTypeFileList.forEach((file) => {
						// Even larger line here. :(
						folderDict["/"][customizationImageFolderName + "/"][customizationCategoryFolderName + "/"][customizationTypeFolderName + "/"][customizationCoreFolderName + "/"][parentTypeElement.folderName + "/"][file.originalFileName.replace(/\./g, ",")] = file.fileName;
					});
				}
			}
		}
	}

	console.log("Folder dict generated: ", folderDict);

	wixData.query(KeyConstants.KEY_VALUE_DB)
		.eq("key", KeyConstants.KEY_VALUE_CUSTOMIZATION_FOLDERS_KEY)
		.find()
		.then((results) => {
			if (results.items.length > 0) {
				let item = results.items[0];
				item.value = folderDict;
				wixData.save(KeyConstants.KEY_VALUE_DB, item);
			}
			else {
				wixData.save(KeyConstants.KEY_VALUE_DB, {"key": KeyConstants.KEY_VALUE_CUSTOMIZATION_FOLDERS_KEY, "value": folderDict});
			}
		})
}

// Retrieves an item's image URL based on the customizationCategory, customizationType, customizationCore (if applicable), parentCustomizationType (for attachments) path, and mimeType.
// The Customization Category can be one of the accepted category keys (e.g. ARMOR_KEY or BODY_AND_AI_KEY) and is used to select the folder within Customization Images to open.
// The Customization Type can be one of the valid customizationType values and is used to select the folder within "Customization Images/[Customization Category Folder]/"
// The Customization Core specifies the name of the core (e.g. "Yoroi"), which is necessary to place the image in "Customization Images/[Customization Category Folder]/[customizationCore]/"
// The Parent Customization Type is only used for attachments. It is needed to place the attachment image in "Customization Images/[Customization Category Folder]/[customizationCore]/[parentCustomizationType]"
// The waypointPath is the Waypoint filepath used to retrieve the image from Waypoint if necessary.
// The mimeType comes directly from the item JSON and is usually 'image/png'.
export async function getCustomizationImageUrl(folderDict, headers, title, waypointPath, mimeType, customizationCategory, customizationType, customizationCore = null, parentCustomizationType = null) {
	// We want to check and see if the file already exists. It will have a filename of the form "[title] [customizationType]", e.g. Wild Kovan Armor Coating.
	// First, we start with the root folder and list all directories within it. We're looking for a folder entitled "Customization Images".

	// The file path has the form 
	// /Customization Images/
	// CUSTOMIZATION_CATEGORY_FOLDER_DICT[customizationCategory]/
	// CUSTOMIZATION_TYPE_FOLDER_DICT[customizationCategory][customizationType]/ 		If not Consumable
	// customizationCore/ 																If not core agnostic or non-core
	// CUSTOMIZATION_TYPE_FOLDER_DICT[KeyConstants.ARMOR_KEY][parentCustomizationType]/ If attachment
	// [title] [customizationType].png

	// Time to traverse our folder tree while building the file path.
	let subFolderDict = {}
	let folderExists = true;
	if ("/" in folderDict) {
		subFolderDict = folderDict["/"];
	}
	else {
		folderExists = false;
	}

	if (folderExists && ("Customization Images/" in subFolderDict)) {
		subFolderDict = subFolderDict["Customization Images/"];
	}
	else {
		folderExists = false;
	}

	if (folderExists && ((CUSTOMIZATION_CATEGORY_FOLDER_DICT[customizationCategory] + "/") in subFolderDict)) {
		subFolderDict = subFolderDict[CUSTOMIZATION_CATEGORY_FOLDER_DICT[customizationCategory] + "/"];
	}
	else {
		folderExists = false;
	}


	let mediaPath = "/Customization Images/" + CUSTOMIZATION_CATEGORY_FOLDER_DICT[customizationCategory] + "/";
	if (customizationCategory != KeyConstants.CONSUMABLES_KEY) {
		mediaPath = mediaPath + CUSTOMIZATION_TYPE_FOLDER_DICT[customizationCategory][customizationType] + "/";
		if (folderExists && ((CUSTOMIZATION_TYPE_FOLDER_DICT[customizationCategory][customizationType] + "/") in subFolderDict)) {
			subFolderDict = subFolderDict[CUSTOMIZATION_TYPE_FOLDER_DICT[customizationCategory][customizationType] + "/"];
		}
		else {
			folderExists = false;
		}

		if (HAS_CORE_ARRAY.includes(customizationCategory) && !IS_CROSS_CORE_ARRAY_DICT[customizationCategory].includes(customizationType)){
			mediaPath = mediaPath + customizationCore + "/";
			if (folderExists && ((customizationCore + "/") in subFolderDict)) {
				subFolderDict = subFolderDict[customizationCore + "/"];
			}
			else {
				folderExists = false;
			}

			if (customizationCategory == KeyConstants.ARMOR_ATTACHMENT_KEY) {
				mediaPath = mediaPath + CUSTOMIZATION_TYPE_FOLDER_DICT[KeyConstants.ARMOR_KEY][parentCustomizationType] + "/";
				if (folderExists && ((CUSTOMIZATION_TYPE_FOLDER_DICT[KeyConstants.ARMOR_KEY][parentCustomizationType] + "/") in subFolderDict)) {
					subFolderDict = subFolderDict[CUSTOMIZATION_TYPE_FOLDER_DICT[KeyConstants.ARMOR_KEY][parentCustomizationType] + "/"];
				}
				else {
					folderExists = false;
				}
			}
		}
	}

	
	//console.log("Item Directory Path: " + mediaPath);

	let fileSystemSafeTitle = title.replace(/\//g, "_").replace(/\\/g, "_").replace(/\?/, "_").replace(/:/, "_"); // Clean out some of the common illegal characters.

	if (folderExists) {
		//console.log("Directory Path found.");

		let fileKey = fileSystemSafeTitle.replace(/\./g, ",") + " " + customizationType + ",png";

		if (customizationCategory == KeyConstants.SHOP_KEY) {
			fileKey = fileSystemSafeTitle.replace(/\./g, ",") + " Bundle,png";
		}

		if (fileKey in subFolderDict) {
			//console.log("Existing File found for " + fileKey);
			let fileData = await mediaManager.getFileInfo(subFolderDict[fileKey]);
			return fileData.fileUrl;
		}
		else {
			console.log("File not found for " + fileKey + " in " + mediaPath);
			if (customizationCategory != KeyConstants.SHOP_KEY) {
				return await addCustomizationImageToMediaManager(headers, waypointPath, mimeType, mediaPath, fileSystemSafeTitle + " " + customizationType + ".png");
			}
			else {
				return await addCustomizationImageToMediaManager(headers, waypointPath, mimeType, mediaPath, fileSystemSafeTitle + " Bundle.png");
			}
			
		}
	}
	else {
		// If the directory didn't exist before, we need to make it by adding the image, then updating the generateFolderDict() key. 
		// We need to update the key or we'll get duplicate files in new folders. This may take some time, unfortunately, but is probably safest.
		// TODO: Consider if more efficient solution would be beneficial.
		console.log("Directory not found for " + mediaPath + ".");
		let fileUrl = "";
		if (customizationCategory != KeyConstants.SHOP_KEY) {
			fileUrl = await addCustomizationImageToMediaManager(headers, waypointPath, mimeType, mediaPath, fileSystemSafeTitle + " " + customizationType + ".png");
		}
		else {
			fileUrl = await addCustomizationImageToMediaManager(headers, waypointPath, mimeType, mediaPath, fileSystemSafeTitle + " Bundle.png");
		}
		generateFolderDict();
		return fileUrl;
	}
}

// This function compares the contents of two arrays and returns true if the contents match, regardless of order.
// Graciously provided by Maciej Krawczyk at https://stackoverflow.com/questions/6229197/how-to-know-if-two-arrays-have-the-same-values
function arrayCompare(_arr1, _arr2) {
    if (
      !Array.isArray(_arr1)
      || !Array.isArray(_arr2)
      || _arr1.length !== _arr2.length
      ) {
        return false;
      }
    
    // .concat() to not mutate arguments
    const arr1 = _arr1.concat().sort();
    const arr2 = _arr2.concat().sort();
    
    for (let i = 0; i < arr1.length; i++) {
        if (arr1[i] !== arr2[i]) {
            return false;
         }
    }
    
    return true;
}

export function getCurrentDateTimeString() {
	var today = new Date();
	var monthString = (today.getMonth() + 1).toString();
	while (monthString.length < 2) {
		monthString = "0" + monthString;
	}

	var dateString = today.getDate().toString();
	while (dateString.length < 2) {
		dateString = "0" + dateString;
	}

	var yearString = today.getFullYear().toString();

	var hourString = today.getHours().toString();
	while (hourString.length < 2) {
		hourString = "0" + hourString;
	}

	var minuteString = today.getMinutes().toString();
	while (minuteString.length < 2) {
		minuteString = "0" + minuteString;
	}
	
	var secondString = today.getSeconds().toString();
	while (secondString.length < 2) {
		secondString = "0" + secondString;
	}

	var date = monthString + '-' + dateString + '-' + yearString;
	var time = hourString + ":" + minuteString + ":" + secondString;
	return date + " " + time;
}

// New fields needed:
// - Hidden (boolean); need to add default filter to exclude hidden items to code.
// - Needs Review (boolean); can filter to see true items, manually address them, and mark them as false.
// - Change Log (array); indicates what information has been changed (from what to what). Otherwise, indicates item was added.

// This function takes care of the Needs Review boolean flag and adds a new entry to the Change Log. It changes the original Json's Changelog only.
function markItemAsChanged(itemJson, originalJson, fieldChanged) {
	itemJson.needsReview = true;

	
	var datetime = getCurrentDateTimeString();

	if (originalJson.changeLog) {
		originalJson.changeLog.unshift(datetime + ": Changed " + fieldChanged + ", Was: " + originalJson[fieldChanged] + ", Is: " + itemJson[fieldChanged]);
		itemJson.changeLog = originalJson.changeLog;
	}
	else {
		originalJson.changeLog = [(datetime + ": Changed " + fieldChanged + ", Was: " + originalJson[fieldChanged] + ", Is: " + itemJson[fieldChanged])];
		itemJson.changeLog = originalJson.changeLog;
	}

	return [itemJson, originalJson]; // We need to return both Json objects in an array to be able to save our changelog.
}

// This function returns an array of assorted dictionaries that can be used instead of repeat queries.
// [0]: qualityDict
// [1]: releaseDict
// [2]: manufacturerArray (index aligns with Waypoint ID num)

export async function getGeneralDictsAndArraysFromDbs() {
	let qualityDict = {}; // The keys will be quality values (e.g. "Epic" or "Legendary"), and the values will be quality IDs.
	await wixData.query(KeyConstants.QUALITY_DB)
		.find()
		.then((results) => {
			if (results.items.length > 0) {
				for (let i = 0; i < results.items.length; ++i) {
					qualityDict[results.items[i].quality] = results.items[i]._id;
				}
			}
			else {
				throw "No quality values found in the DB! Major emergency!";
			}
		});

	// Next, we do the release.
	let releaseDict = {}; // The keys will be release names (e.g. "Season 1"), and the values are the associated IDs.
	await wixData.query(KeyConstants.RELEASE_DB)
		.find()
		.then((results) => {
			if (results.items.length > 0) {
				for (let i = 0; i < results.items.length; ++i) {
					releaseDict[results.items[i].release] = results.items[i]._id;
				}
			}
			else {
				throw "No release values found in the DB! Major emergency!";
			}
		});

	// Finally, we do the manufacturer. This one's unique and assumes that the manufacturers returned by this query exactly match those in metadata/Metadata.json.
	let manufacturerArray = [];
	await wixData.query(KeyConstants.MANUFACTURER_DB)
		.ascending("manufacturer")
		.ne("manufacturer", "(Pending)")
		.ne("manufacturer", "N/A")
		.find()
		.then((results) => {
			if (results.items.length > 0) {
				//console.log(results.items);
				for (let i = 0; i < results.items.length; ++i) {
					manufacturerArray.push(results.items[i]._id);
				}
			}
			else {
				throw "No manufacturers returned. This ain't good.";
			}
		});

	return [qualityDict, releaseDict, manufacturerArray];
}

// This must execute only after all the cores have been added to the DB. It returns the type and core ID dicts:
// [0]: customizationTypeIdDict
// [1]: coreIdDict
export async function getCategorySpecificDictsAndArraysFromDbs(customizationCategory) {
	let customizationTypeIdDict = {};
	if (customizationCategory != KeyConstants.ARMOR_ATTACHMENT_KEY) {
	// Time to get the ID of the matching customization type.
	await wixData.query(CUSTOMIZATION_CATEGORY_SPECIFIC_VARS[customizationCategory].SocketDb)
		.find()
		.then((results) => {
			if (results.items.length > 0) {
				for (let i = 0; i < results.items.length; i++) {
					customizationTypeIdDict[results.items[i][CUSTOMIZATION_CATEGORY_SPECIFIC_VARS[customizationCategory].SocketNameField]] = results.items[i]._id;
				}
			}
			else {
				throw "No customization types found for category " + customizationCategory;
			}
		});
	}
	
	// Now that we have the matching customization type ID, we need to get a list of core items matching the contents of our core array.
	// Luckily, the site and Waypoint align on the naming convention (quite intentionally).
	let coreIdDict = {};
	if (HAS_CORE_ARRAY.includes(customizationCategory) && customizationCategory != KeyConstants.ARMOR_ATTACHMENT_KEY) {
		await wixData.query(CUSTOMIZATION_CATEGORY_SPECIFIC_VARS[customizationCategory].CoreDb)
			.find() // We're gonna do our own filtering. It's a bit slower, but probably beats having to build a filter for this. Maybe. We'll see.
			.then((results) => {
				if (results.items.length > 0) {
					for (let i = 0; i < results.items.length; i++) {
						coreIdDict[results.items[i][CUSTOMIZATION_CATEGORY_SPECIFIC_VARS[customizationCategory].CoreNameField]] = results.items[i]._id;
					}
				}
				else {
					throw "Did not return any items from the core DB. DEFCON 1!!!";
				}
			});
	}

	return [customizationTypeIdDict, coreIdDict];
}

// This function will use the following logic:
// If item exists in DB (check name, customization type, and core)
// 	   Compare each existing value with the new value. If not matching:
// 	       Replace existing with new (except for source, sourcetype, image, currentlyAvailable, hidden (if false)) 
//         Log all changes to changeLog entry for item.
//         Mark item as "Needs Review".
// Otherwise
//     Add item to DB.
//	   Log item as added.
//     Mark item as "Needs Review".
// It's more efficient to add items all at once, so this will just assemble the JSON needed to add an item to the DB. If it returns -1, an error occurred.
// customizationCategory: One of the following: "Armor", "Weapon", "Vehicle", "BodyAndAi", "SpartanId", "Consumable"
// customizationDetails: A dictionary object containing each of the properties of the item to be added:
/*
	{
		"Title": [itemName],
		"Type": [waypointType],
		"MediaPath": [waypointImagePath],
		"MimeType": [waypointMimeType],
		"Cores": [coreNameArray], // Only available on core-based customizations. Is an array to support cross-core pieces. Will only include "Any" if piece is fully cross-core.
		"Quality": [qualityName],
		"Description": [lore],
		"ManufacturerId": [manufacturerIndex], // The index of the manufacturer when all are listed in alphabetical order.
		"Season": [release],
		"RewardTrack": [waypointPassPath], // This may be null or the empty string. If it exists, it can be used to generate the source.
		"CustomAvailability": [source], // This is almost always null or the empty string.
		"HideUntilOwned": [hidden], // This will usually be honored, except in the case of promo items.
		"Attachments": [attachmentArray] // Contains an array of attachment names that apply to this item. Parent item needs to be added after the attachments are added to the DB.
		"ParentType": [parentWaypointType] // This should only really be used for attachment items.
		"WaypointId": [waypointId] // We're going to be relating items in the database with the Waypoint ID, so we should start adding it.
	}
*/
export async function getCustomizationItemToSave(folderDict, headers, customizationCategory, customizationDetails, generalDictsAndArrays, categorySpecificDictsAndArrays) {
	// If we don't have variables defined for the customization category, we need to get out now. Everything will break otherwise.
	if(!(customizationCategory in CUSTOMIZATION_CATEGORY_SPECIFIC_VARS)) {
		console.error("Invalid customizationCategory value: " + customizationCategory);
		return -1;
	}
	else if (!(generalDictsAndArrays) || generalDictsAndArrays.length != 3) { // We expect 3 dicts/arrays in this construct.
		console.error("Unexpected length for generalDictsAndArrays. Expected 3, got ", generalDictsAndArrays.length);
	}
	else if (!(categorySpecificDictsAndArrays) || categorySpecificDictsAndArrays.length != 2) { // We expect 2 dicts/arrays in this construct.
		console.error("Unexpected length for categorySpecificDictsAndArrays. Expected 2, got ", categorySpecificDictsAndArrays.length);
	}

	// Extract the dicts and array from generalDictsAndArrays.
	// [0]: qualityDict
	// [1]: releaseDict
	// [2]: manufacturerArray (index aligns with Waypoint ID num)
	let qualityDict = generalDictsAndArrays[0];
	let releaseDict = generalDictsAndArrays[1];
	let manufacturerArray = generalDictsAndArrays[2];

	// Extract the dicts from categorySpecificDictsAndArrays.
	// [0]: customizationTypeIdDict
	// [1]: coreIdDict
	let customizationTypeIdDict = categorySpecificDictsAndArrays[0];
	let coreIdDict = categorySpecificDictsAndArrays[1];
	
	// We need to check a few things before we can see if the item already has an entry.
	// For one, since this item has a Core, we can guarantee uniqueness by checking for items with matching itemName, customizationTypeReference, and armorCoreReferences. 
	// That last one needs to be an inclusion, not an equality, and it only applies to non-cross-core items.
	// To start, we need to get the corresponding IDs for the reference fields. Let's begin with customizationTypeReference.

	// We had our own customization type setup long before we knew theirs. Let's convert it using our dictionary!
	let siteCustomizationType = CUSTOMIZATION_WAYPOINT_TO_SITE_KEYS[customizationCategory][customizationDetails.Type];
	let customizationTypeId = "";

	if (customizationCategory != KeyConstants.ARMOR_ATTACHMENT_KEY) {
		// Time to get the ID of the matching customization type.
		customizationTypeId = customizationTypeIdDict[siteCustomizationType];
	}
	
	// Now that we have the matching customization type ID, we need to get a list of armor core items matching the contents of our core array.
	// Luckily, the site and Waypoint align on the naming convention (quite intentionally).
	let coreIdArray = [];
	if (HAS_CORE_ARRAY.includes(customizationCategory) && customizationCategory != KeyConstants.ARMOR_ATTACHMENT_KEY) {
		for (let coreName in coreIdDict) {
			if (customizationDetails.Cores.includes(coreName)) {
				coreIdArray.push(coreIdDict[coreName]);
			}
		}
		
	}

	// We need to convert the array of attachment names to an array of attachment IDs. This one is probably best to filter first.
	// TODO: Consider whether this would be worth including as a dict that gets passed in (would need to be generated after all attachments are added but before items using attachments).
	let attachmentIdArray = [];
	if (customizationCategory == KeyConstants.ARMOR_KEY && customizationDetails.Attachments && customizationDetails.Attachments.length > 0) {
		let query = wixData.query(CUSTOMIZATION_CATEGORY_SPECIFIC_VARS[KeyConstants.ARMOR_ATTACHMENT_KEY].CustomizationDb)
			.eq(CUSTOMIZATION_CATEGORY_SPECIFIC_VARS[KeyConstants.ARMOR_ATTACHMENT_KEY].CustomizationNameField, customizationDetails.Attachments[0])
		
		for (let i = 1; i < customizationDetails.Attachments.length; i++) {
			query = query.or(wixData.query(CUSTOMIZATION_CATEGORY_SPECIFIC_VARS[KeyConstants.ARMOR_ATTACHMENT_KEY].CustomizationDb)
				.eq(CUSTOMIZATION_CATEGORY_SPECIFIC_VARS[KeyConstants.ARMOR_ATTACHMENT_KEY].CustomizationNameField, customizationDetails.Attachments[i]));
		}

		await query.find()
			.then((results) => {
				if (results.items.length > 0) {
					for (let i = 0; i < results.items.length; i++) {
						//console.log(results.items[i].itemName);
						attachmentIdArray.push(results.items[i]._id);
					}
				}
				else {
					throw "Did not return any matching attachments from the attachment DB. Was looking for " + customizationDetails.Attachments.toString();
				}
			});
	}
	
	// Okay, now we've got a collection of IDs robust enough to select a specific item 
	// (In the future, cross-core pieces might complicate this a little bit, but not too bad.)
	// It's time to select the item!
	let existingItem = {};

	if (HAS_CORE_ARRAY.includes(customizationCategory) && customizationCategory != KeyConstants.ARMOR_ATTACHMENT_KEY) {
		await wixData.query(CUSTOMIZATION_CATEGORY_SPECIFIC_VARS[customizationCategory].CustomizationDb)
			.eq("waypointId", customizationDetails.WaypointId)
			//.eq(CUSTOMIZATION_CATEGORY_SPECIFIC_VARS[customizationCategory].CustomizationNameField, customizationDetails.Title)
			//.eq(CUSTOMIZATION_CATEGORY_SPECIFIC_VARS[customizationCategory].CustomizationSocketReferenceField, customizationTypeId)
			//.hasSome(CUSTOMIZATION_CATEGORY_SPECIFIC_VARS[customizationCategory].CustomizationCoreReferenceField, coreIdArray) // The hasSome filter could catch multiple listings in the case of newly cross-core items.
			.include(CUSTOMIZATION_CATEGORY_SPECIFIC_VARS[customizationCategory].CustomizationCoreReferenceField)
			.find()
			.then((results) => {
				if (results.items.length == 1) { // This is the expected case for now. If cross-core occurs in the future, this will affect some things.
					existingItem = results.items[0]; // We just need to store it for the moment.
				}
				else if (results.items.length > 1) { // This is the expected case for newly cross-core items (which could have multiple listings, one for each core)
					console.warn("Cross-core has affected the " + results.items[0][CUSTOMIZATION_CATEGORY_SPECIFIC_VARS[customizationCategory].CustomizationNameField] + " " + siteCustomizationType);
					existingItem = results.items[0]; // We'll still just work on the first item, but throwing a warning tells us to look for duplicates.
				}
				else {
					existingItem = null;
				}
			});
	}
	/*else if (customizationCategory != KeyConstants.ARMOR_ATTACHMENT_KEY) {
		await wixData.query(CUSTOMIZATION_CATEGORY_SPECIFIC_VARS[customizationCategory].CustomizationDb)
			.eq(CUSTOMIZATION_CATEGORY_SPECIFIC_VARS[customizationCategory].CustomizationNameField, customizationDetails.Title)
			.eq(CUSTOMIZATION_CATEGORY_SPECIFIC_VARS[customizationCategory].CustomizationSocketReferenceField, customizationTypeId)
			.find()
			.then((results) => {
				if (results.items.length == 1) { // This is the expected case for now. If cross-core occurs in the future, this will affect some things.
					existingItem = results.items[0]; // We just need to store it for the moment.
				}
				else if (results.items.length > 1) { // This is unexpected for non-core items.
					throw "Multiple items returned despite assumed uniqueness. Tried querying based on " + customizationDetails.Title + " and " + siteCustomizationType;
				}
				else {
					existingItem = null;
				}
			});
	}*/
	else {
		await wixData.query(CUSTOMIZATION_CATEGORY_SPECIFIC_VARS[customizationCategory].CustomizationDb)
			.eq("waypointId", customizationDetails.WaypointId)
			.find()
			.then((results) => {
				if (results.items.length == 1) { // This is the expected case for now. If cross-core occurs in the future, this will affect some things.
					existingItem = results.items[0]; // We just need to store it for the moment.
				}
				else if (results.items.length > 1) { // This is unexpected for armor attachments.
					throw "Multiple items returned despite assumed uniqueness. Tried querying based on " + customizationDetails.WaypointId;
				}
				else {
					existingItem = null;
				}
			});
	}
	
	// We learned about the .include() function, so we can just iterate over each item in our core array to get the IDs. (Die query!!!)
	let originalCoreIds = [];
	if (HAS_CORE_ARRAY.includes(customizationCategory) && customizationCategory != KeyConstants.ARMOR_ATTACHMENT_KEY && existingItem) {
		let coreItemArray = existingItem[CUSTOMIZATION_CATEGORY_SPECIFIC_VARS[customizationCategory].CustomizationCoreReferenceField];
		for (let i = 0; i < coreItemArray.length; ++i) {
			originalCoreIds.push(coreItemArray[i]._id);
		}
		existingItem[CUSTOMIZATION_CATEGORY_SPECIFIC_VARS[customizationCategory].CustomizationCoreReferenceField] = originalCoreIds; // This replaces the entire object array with just a string Array.
	}

	// We need to get the attachment multi-reference field separately through a queryReferenced command because query doesn't return it.
	// When choosing between getting the core and the attachments, it was clear which would be the better choice.
	let originalAttachmentIds = [];
	if ((customizationCategory in CUSTOMIZATION_TYPES_WITH_ATTACHMENTS) && CUSTOMIZATION_TYPES_WITH_ATTACHMENTS[customizationCategory].includes(siteCustomizationType) && (existingItem)) {
		await wixData.queryReferenced(CUSTOMIZATION_CATEGORY_SPECIFIC_VARS[customizationCategory].CustomizationDb, existingItem._id, CUSTOMIZATION_CATEGORY_SPECIFIC_VARS[customizationCategory].CustomizationAttachmentReferenceField)
			.then((results) => {
				if (results.items.length > 0) {
					// Push each ID onto the array.
					results.items.forEach((item) => {
						originalAttachmentIds.push(item._id);
					})
				}
				/*else {
					console.log("No Attachments found for existing item: ", existingItem);
				}*/
			});
		existingItem[CUSTOMIZATION_CATEGORY_SPECIFIC_VARS[customizationCategory].CustomizationAttachmentReferenceField] = originalAttachmentIds;
	}

	// The next step is to compare the current item with things in our arguments, but we need to translate some names into IDs, namely for quality, manufacturer, and release.
	// Let's start with quality.
	let qualityId = "";
	qualityId = qualityDict[customizationDetails.Quality];

	// Next, we do the release.
	let releaseId = "";
	releaseId = releaseDict[customizationDetails.Season];

	// Finally, we do the manufacturer.
	let manufacturerId = "";
	manufacturerId = manufacturerArray[customizationDetails.ManufacturerId];

	let itemJsonToInsert = {};

	// If we found an existing item, we need to compare some of the existing fields with the new ones to see if it should be added.
	// We know the itemName matches, as does the customization Type. There may be more armor cores to add, so we'll check that.
	//console.log(existingItem);
	if (existingItem) {
		//console.log ("Updating existing item.");

		let itemJson = JSON.parse(JSON.stringify(existingItem)); // We start with the original fields in the item, but we need to make a copy.
		let changed = false; // If the item is changed this flag will be made true. Allows us to avoid adding unnecessary JSONs to our DB array.

		if (!itemJson.waypointId || itemJson.waypointId == "") {
			itemJson.waypointId = customizationDetails.WaypointId; // We're saving the Waypoint ID here.
			changed = true;
		}

		if (HAS_CORE_ARRAY.includes(customizationCategory) && customizationDetails.Cores[0] != "Any") {
			// Note that this means we'll be storing cross-core items in random core-specific folders for now. TODO: Find a better option if this becomes problematic in the future.
			let parentSiteType = null; // This only applies to attachments that have parent items (e.g. for Helmet Attachments, this will be "Helmet")
			if ("ParentType" in customizationDetails && customizationCategory == KeyConstants.ARMOR_ATTACHMENT_KEY) {
				parentSiteType = CUSTOMIZATION_WAYPOINT_TO_SITE_KEYS[CUSTOMIZATION_CATEGORY_SPECIFIC_VARS[customizationCategory].ParentKey][customizationDetails.ParentType];
			}
			else if (customizationCategory == KeyConstants.ARMOR_ATTACHMENT_KEY) {
				// We need to know the parent item but it wasn't supplied. Time to die.
				console.error("Parent item not supplied for attachment " + customizationDetails.Title);
				return -1;
			}

			let newImageUrl = await getCustomizationImageUrl(folderDict, headers, customizationDetails.Title, customizationDetails.MediaPath, customizationDetails.MimeType, customizationCategory, siteCustomizationType, customizationDetails.Cores[0], parentSiteType);
			if (existingItem[CUSTOMIZATION_CATEGORY_SPECIFIC_VARS[customizationCategory].CustomizationImageField] != newImageUrl) {
				itemJson[CUSTOMIZATION_CATEGORY_SPECIFIC_VARS[customizationCategory].CustomizationImageField] = newImageUrl;

				// Update the needs review item and add a log to the changelog.
				changed = true;
				let returnedJsons = markItemAsChanged(itemJson, existingItem, CUSTOMIZATION_CATEGORY_SPECIFIC_VARS[customizationCategory].CustomizationImageField);
				itemJson = returnedJsons[0];
				existingItem = returnedJsons[1];
			}

		}
		else {
			let newImageUrl = await getCustomizationImageUrl(folderDict, headers, customizationDetails.Title, customizationDetails.MediaPath, customizationDetails.MimeType, customizationCategory, siteCustomizationType);
			if (existingItem[CUSTOMIZATION_CATEGORY_SPECIFIC_VARS[customizationCategory].CustomizationImageField] != newImageUrl) {
				itemJson[CUSTOMIZATION_CATEGORY_SPECIFIC_VARS[customizationCategory].CustomizationImageField] = newImageUrl;

				// Update the needs review item and add a log to the changelog.
				changed = true;
				let returnedJsons = markItemAsChanged(itemJson, existingItem, CUSTOMIZATION_CATEGORY_SPECIFIC_VARS[customizationCategory].CustomizationImageField);
				itemJson = returnedJsons[0];
				existingItem = returnedJsons[1];
			}
		}

		// This case is unique. We can't actually add this outright, but need to call the replaceReference function for it.
		if (HAS_CORE_ARRAY.includes(customizationCategory) && customizationCategory !== KeyConstants.ARMOR_ATTACHMENT_KEY && !arrayCompare(originalCoreIds, coreIdArray)) { // If the contents of the arrays don't match at all.
			itemJson[CUSTOMIZATION_CATEGORY_SPECIFIC_VARS[customizationCategory].CustomizationCoreReferenceField] = coreIdArray;

			// Update the needs review item and add a log to the changelog.
			changed = true;
			let returnedJsons = markItemAsChanged(itemJson, existingItem, CUSTOMIZATION_CATEGORY_SPECIFIC_VARS[customizationCategory].CustomizationCoreReferenceField);
			itemJson = returnedJsons[0];
			existingItem = returnedJsons[1];
		}

		// Gotta love multi-references. -_- We can't actually add this outright, but need to call the replaceReference function for it, too.
		if (customizationCategory == KeyConstants.ARMOR_KEY && !arrayCompare(originalAttachmentIds, attachmentIdArray)) {
			itemJson[CUSTOMIZATION_CATEGORY_SPECIFIC_VARS[customizationCategory].CustomizationAttachmentReferenceField] = attachmentIdArray;

			// Update the needs review item and add a log to the changelog.
			changed = true;
			let returnedJsons = markItemAsChanged(itemJson, existingItem, CUSTOMIZATION_CATEGORY_SPECIFIC_VARS[customizationCategory].CustomizationAttachmentReferenceField);
			itemJson = returnedJsons[0];
			existingItem = returnedJsons[1];
		}

		if (qualityId != existingItem[CUSTOMIZATION_CATEGORY_SPECIFIC_VARS[customizationCategory].CustomizationQualityReferenceField]) {
			itemJson[CUSTOMIZATION_CATEGORY_SPECIFIC_VARS[customizationCategory].CustomizationQualityReferenceField] = qualityId;

			// Update the needs review item and add a log to the changelog.
			changed = true;
			let returnedJsons = markItemAsChanged(itemJson, existingItem, CUSTOMIZATION_CATEGORY_SPECIFIC_VARS[customizationCategory].CustomizationQualityReferenceField);
			itemJson = returnedJsons[0];
			existingItem = returnedJsons[1];
		}

		if (customizationDetails.Description.normalize() !== existingItem[CUSTOMIZATION_CATEGORY_SPECIFIC_VARS[customizationCategory].CustomizationLoreField].normalize()) {
			itemJson[CUSTOMIZATION_CATEGORY_SPECIFIC_VARS[customizationCategory].CustomizationLoreField] = customizationDetails.Description;

			// Update the needs review item and add a log to the changelog.
			changed = true;
			let returnedJsons = markItemAsChanged(itemJson, existingItem, CUSTOMIZATION_CATEGORY_SPECIFIC_VARS[customizationCategory].CustomizationLoreField);
			itemJson = returnedJsons[0];
			existingItem = returnedJsons[1];
		}

		if (manufacturerId != existingItem[CUSTOMIZATION_CATEGORY_SPECIFIC_VARS[customizationCategory].CustomizationManufacturerReferenceField]) {
			itemJson[CUSTOMIZATION_CATEGORY_SPECIFIC_VARS[customizationCategory].CustomizationManufacturerReferenceField] = manufacturerId;

			// Update the needs review item and add a log to the changelog.
			changed = true;
			let returnedJsons = markItemAsChanged(itemJson, existingItem, CUSTOMIZATION_CATEGORY_SPECIFIC_VARS[customizationCategory].CustomizationManufacturerReferenceField);
			itemJson = returnedJsons[0];
			existingItem = returnedJsons[1];
		}

		if (releaseId != existingItem[CUSTOMIZATION_CATEGORY_SPECIFIC_VARS[customizationCategory].CustomizationReleaseReferenceField]) {
			itemJson[CUSTOMIZATION_CATEGORY_SPECIFIC_VARS[customizationCategory].CustomizationReleaseReferenceField] = releaseId;

			// Update the needs review item and add a log to the changelog.
			changed = true;
			let returnedJsons = markItemAsChanged(itemJson, existingItem, CUSTOMIZATION_CATEGORY_SPECIFIC_VARS[customizationCategory].CustomizationReleaseReferenceField);
			itemJson = returnedJsons[0];
			existingItem = returnedJsons[1];
		}

		if (existingItem[CUSTOMIZATION_CATEGORY_SPECIFIC_VARS[customizationCategory].CustomizationSourceField].includes("(Pending)")) { // If we don't have a source already, we want to update. But only in this case.
			if (customizationDetails.CustomAvailability != null && customizationDetails.CustomAvailability != "") {
				itemJson[CUSTOMIZATION_CATEGORY_SPECIFIC_VARS[customizationCategory].CustomizationSourceField] = customizationDetails.CustomAvailability;

				changed = true;
				let returnedJsons = markItemAsChanged(itemJson, existingItem, CUSTOMIZATION_CATEGORY_SPECIFIC_VARS[customizationCategory].CustomizationSourceField);
				itemJson = returnedJsons[0];
				existingItem = returnedJsons[1];
			}
			else if (customizationDetails.RewardTrack != null && customizationDetails.RewardTrack != "") {
				itemJson[CUSTOMIZATION_CATEGORY_SPECIFIC_VARS[customizationCategory].CustomizationSourceField] = customizationDetails.RewardTrack;

				changed = true;
				let returnedJsons = markItemAsChanged(itemJson, existingItem, CUSTOMIZATION_CATEGORY_SPECIFIC_VARS[customizationCategory].CustomizationSourceField);
				itemJson = returnedJsons[0];
				existingItem = returnedJsons[1];
			}
		}

		if (!customizationDetails.HideUntilOwned && existingItem.hidden) {
			itemJson.hidden = customizationDetails.HideUntilOwned; // This addition will allow the automation to show items as they become visible.

			changed = true;
			let returnedJsons = markItemAsChanged(itemJson, existingItem, "hidden");
			itemJson = returnedJsons[0];
			existingItem = returnedJsons[1];
		}

		let newAltText = customizationDetails.Title + " " + siteCustomizationType;
		if (newAltText != existingItem.altText) {
			itemJson.altText = newAltText;

			changed = true;
			let returnedJsons = markItemAsChanged(itemJson, existingItem, "altText");
			itemJson = returnedJsons[0];
			existingItem = returnedJsons[1];
		}

		if (!changed) { // If we didn't make any changes to the item, we can just skip it by returning 1.
			//console.log("No changes needed for ", customizationDetails.Title, " ", siteCustomizationType, " ", customizationDetails.Cores, ". Skipping...");
			return 1;
		}
		
		//console.log(existingItem);
		//console.log(itemJson);
		itemJsonToInsert = itemJson;
	}
	else { // The item wasn't found, so we need to create a new item.
		//console.log("Adding new item");

		let itemJson = {};

		itemJson.waypointId = customizationDetails.WaypointId; // We're saving the Waypoint ID here.

		// Add the item name and customization type.
		itemJson[CUSTOMIZATION_CATEGORY_SPECIFIC_VARS[customizationCategory].CustomizationNameField] = customizationDetails.Title;
		if (customizationCategory != KeyConstants.ARMOR_ATTACHMENT_KEY) {
			itemJson[CUSTOMIZATION_CATEGORY_SPECIFIC_VARS[customizationCategory].CustomizationSocketReferenceField] = customizationTypeId;
		}

		if (HAS_CORE_ARRAY.includes(customizationCategory) && customizationDetails.Cores[0] != "Any") {
			// Note that this means we'll be storing cross-core items in random core-specific folders for now. TODO: Find a better option if this becomes problematic in the future.
			let parentSiteType = null; // This only applies to attachments that have parent items (e.g. for Helmet Attachments, this will be "Helmet")
			if ("ParentType" in customizationDetails && customizationCategory == KeyConstants.ARMOR_ATTACHMENT_KEY) {
				parentSiteType = CUSTOMIZATION_WAYPOINT_TO_SITE_KEYS[CUSTOMIZATION_CATEGORY_SPECIFIC_VARS[customizationCategory].ParentKey][customizationDetails.ParentType];
			}
			else if (customizationCategory == KeyConstants.ARMOR_ATTACHMENT_KEY) {
				// We need to know the parent item but it wasn't supplied. Time to die.
				console.error("Parent item not supplied for attachment " + customizationDetails.Title);
				return -1;
			}

			itemJson.image = await getCustomizationImageUrl(folderDict, headers, customizationDetails.Title, customizationDetails.MediaPath, customizationDetails.MimeType, customizationCategory, siteCustomizationType, customizationDetails.Cores[0], parentSiteType);
		}
		else {
			itemJson.image = await getCustomizationImageUrl(folderDict, headers, customizationDetails.Title, customizationDetails.MediaPath, customizationDetails.MimeType, customizationCategory, siteCustomizationType);
		}

		// Remember to add this field using the replaceReference function.
		if (HAS_CORE_ARRAY.includes(customizationCategory) && (customizationCategory != KeyConstants.ARMOR_ATTACHMENT_KEY)) {
			itemJson[CUSTOMIZATION_CATEGORY_SPECIFIC_VARS[customizationCategory].CustomizationCoreReferenceField] = coreIdArray;
		}

		// Remember to add this field using the replaceReference function.
		if (customizationCategory == KeyConstants.ARMOR_KEY) {
			itemJson[CUSTOMIZATION_CATEGORY_SPECIFIC_VARS[customizationCategory].CustomizationAttachmentReferenceField] = attachmentIdArray;
		}

		itemJson[CUSTOMIZATION_CATEGORY_SPECIFIC_VARS[customizationCategory].CustomizationQualityReferenceField] = qualityId;
		itemJson[CUSTOMIZATION_CATEGORY_SPECIFIC_VARS[customizationCategory].CustomizationLoreField] = customizationDetails.Description;
		itemJson[CUSTOMIZATION_CATEGORY_SPECIFIC_VARS[customizationCategory].CustomizationManufacturerReferenceField] = manufacturerId;
		itemJson[CUSTOMIZATION_CATEGORY_SPECIFIC_VARS[customizationCategory].CustomizationReleaseReferenceField] = releaseId;

		if (customizationDetails.CustomAvailability != null && customizationDetails.CustomAvailability != "") {
			itemJson[CUSTOMIZATION_CATEGORY_SPECIFIC_VARS[customizationCategory].CustomizationSourceField] = customizationDetails.CustomAvailability;
		}
		else if (customizationDetails.RewardTrack != null && customizationDetails.RewardTrack != "") {
			// TODO: Find an efficient way to read the Battle Pass and update the source accordingly.
			itemJson[CUSTOMIZATION_CATEGORY_SPECIFIC_VARS[customizationCategory].CustomizationSourceField] = customizationDetails.RewardTrack;
		}
		else {
			itemJson[CUSTOMIZATION_CATEGORY_SPECIFIC_VARS[customizationCategory].CustomizationSourceField] = "(Pending)";
		}

		itemJson.currentlyAvailable = false; // This is a default value that will almost always be true.
		itemJson.hidden = customizationDetails.HideUntilOwned;
		itemJson.needsReview = true;
		itemJson.altText = customizationDetails.Title + " " + siteCustomizationType;

		var datetime = getCurrentDateTimeString();
		itemJson.changeLog = [(datetime + ": Added item to DB.")];

		itemJsonToInsert = itemJson;
	}

	return itemJsonToInsert;
}

// This function will use the following logic:
// If item exists in DB (check name)
// 	   Compare each existing value with the new value. If not matching:
// 	       Replace existing with new (except for source, sourcetype, image, currentlyAvailable, hidden (if false)) 
//         Log all changes to changeLog entry for item.
//         Mark item as "Needs Review".
// Otherwise
//     Add item to DB.
//	   Log item as added.
//     Mark item as "Needs Review".
// It's more efficient to add items all at once, so this will just assemble the JSON needed to add an item to the DB. If it returns -1, an error occurred.
// customizationCategory: One of the following: "Armor", "Weapon", "Vehicle", "BodyAndAi", "SpartanId", "Consumable"
// customizationDetails: A dictionary object containing each of the properties of the item to be added:
/*
	{
		"Title": [name],
		"Type": [waypointType],
		"MediaPath": [waypointImagePath],
		"MimeType": [waypointMimeType],
		"Quality": [qualityName],
		"Description": [lore],
		"ManufacturerId": [manufacturerIndex], // The index of the manufacturer when all are listed in alphabetical order.
		"Season": [release],
		"RewardTrack": [waypointPassPath], // This may be null or the empty string. If it exists, it can be used to generate the source.
		"CustomAvailability": [source], // This is almost always null or the empty string.
		"HideUntilOwned": [hidden], // This will usually be honored, except in the case of promo items.
		"WaypointId": // This will identify the core based on its Waypoint ID.
		// Might be worth adding the ability to include Sockets in the future, but not really necessary ATM.
	}
*/
async function getCoreItemToSave(folderDict, headers, customizationCategory, customizationDetails, generalDictsAndArrays) {
	// If we don't have variables defined for the customization category, we need to get out now. Everything will break otherwise.
	if(!(customizationCategory in CORE_CATEGORY_SPECIFIC_VARS)) {
		console.error("Invalid customizationCategory value for getCoreItemToSave: " + customizationCategory);
		return -1;
	}
	else if (generalDictsAndArrays.length != 3) { // We expect 3 dicts/arrays in this construct.
		console.error("Unexpected length for generalDictsAndArrays. Expected 3, got ", generalDictsAndArrays.length);
	}

	// Extract the dicts and array from generalDictsAndArrays.
	// [0]: qualityDict
	// [1]: releaseDict
	// [2]: manufacturerArray (index aligns with Waypoint ID num)
	let qualityDict = generalDictsAndArrays[0];
	let releaseDict = generalDictsAndArrays[1];
	let manufacturerArray = generalDictsAndArrays[2];

	let siteCustomizationType = CUSTOMIZATION_WAYPOINT_TO_SITE_KEYS[customizationCategory][customizationDetails.Type]; // This is used for pointing out the Cores folder when adding images.
	
	// We need to check a few things before we can see if the item already has an entry.
	// For one, we can guarantee uniqueness by checking for items with matching name.
	// It's already time to select the item (wow, so easy!)
	let existingItem = {};

	await wixData.query(CORE_CATEGORY_SPECIFIC_VARS[customizationCategory].CoreDb)
		.eq("waypointId", customizationDetails.WaypointId)
		//.eq(CORE_CATEGORY_SPECIFIC_VARS[customizationCategory].CoreNameField, customizationDetails.Title)
		.find()
		.then((results) => {
			if (results.items.length == 1) { // This is the expected case for now. If cross-core occurs in the future, this will affect some things.
				existingItem = results.items[0]; // We just need to store it for the moment.
			}
			else if (results.items.length > 1) { // This shouldn't happen since we would have multiple cores with the same name...
				throw "Too many cores returned for name filter " + customizationDetails.Title;
			}
			else {
				existingItem = null;
			}
		})
		.catch ((error) => {
			console.error(error);
			return -1;
		});
	
	// The next step is to compare the current item with things in our arguments, but we need to translate some name into IDs, namely for quality, manufacturer, and release.
	// Let's start with quality.
	let qualityId = "";
	qualityId = qualityDict[customizationDetails.Quality];

	// Next, we do the release.
	let releaseId = "";
	releaseId = releaseDict[customizationDetails.Season];

	// Finally, we do the manufacturer.
	let manufacturerId = "";
	manufacturerId = manufacturerArray[customizationDetails.ManufacturerId];


	let itemJsonToInsert = {};

	// If we found an existing item, we need to compare some of the existing fields with the new ones to see if it should be added.
	// We know the itemName matches, as does the customization Type. There may be more armor cores to add, so we'll check that.
	//console.log(existingItem);
	if (existingItem) {
		//console.log ("Updating existing item.");

		let itemJson = JSON.parse(JSON.stringify(existingItem)); // This is a hacky way to make a JSON copy, but it'll work since this is JSON.
		let changed = false; // If this flag becomes true, we made a change. Otherwise, we return 1 since we don't need to add anything.

		if (!itemJson.waypointId || itemJson.waypointId == "") {
			itemJson.waypointId = customizationDetails.WaypointId; // We're saving the Waypoint ID here.
			changed = true;
		}
		
		let newImageUrl = await getCustomizationImageUrl(folderDict, headers, customizationDetails.Title, customizationDetails.MediaPath, customizationDetails.MimeType, customizationCategory, siteCustomizationType);
		if (existingItem[CORE_CATEGORY_SPECIFIC_VARS[customizationCategory].CoreImageField] != newImageUrl) {
			itemJson[CORE_CATEGORY_SPECIFIC_VARS[customizationCategory].CoreImageField] = newImageUrl;

			// Update the needs review item and add a log to the changelog.
			changed = true;
			let returnedJsons = markItemAsChanged(itemJson, existingItem, CORE_CATEGORY_SPECIFIC_VARS[customizationCategory].CoreImageField);
			itemJson = returnedJsons[0];
			existingItem = returnedJsons[1];
		}

		if (qualityId != existingItem[CORE_CATEGORY_SPECIFIC_VARS[customizationCategory].CoreQualityReferenceField]) {
			itemJson[CORE_CATEGORY_SPECIFIC_VARS[customizationCategory].CoreQualityReferenceField] = qualityId;

			// Update the needs review item and add a log to the changelog.
			changed = true;
			let returnedJsons = markItemAsChanged(itemJson, existingItem, CORE_CATEGORY_SPECIFIC_VARS[customizationCategory].CoreQualityReferenceField);
			itemJson = returnedJsons[0];
			existingItem = returnedJsons[1];
		}

		if (customizationDetails.Description.normalize() !== existingItem[CORE_CATEGORY_SPECIFIC_VARS[customizationCategory].CoreLoreField].normalize()) {
			itemJson[CORE_CATEGORY_SPECIFIC_VARS[customizationCategory].CoreLoreField] = customizationDetails.Description;

			// Update the needs review item and add a log to the changelog.
			changed = true;
			let returnedJsons = markItemAsChanged(itemJson, existingItem, CORE_CATEGORY_SPECIFIC_VARS[customizationCategory].CoreLoreField);
			itemJson = returnedJsons[0];
			existingItem = returnedJsons[1];
		}

		if (manufacturerId != existingItem[CORE_CATEGORY_SPECIFIC_VARS[customizationCategory].CoreManufacturerReferenceField]) {
			itemJson[CORE_CATEGORY_SPECIFIC_VARS[customizationCategory].CoreManufacturerReferenceField] = manufacturerId;

			// Update the needs review item and add a log to the changelog.
			changed = true;
			let returnedJsons = markItemAsChanged(itemJson, existingItem, CORE_CATEGORY_SPECIFIC_VARS[customizationCategory].CoreManufacturerReferenceField);
			itemJson = returnedJsons[0];
			existingItem = returnedJsons[1];
		}

		if (releaseId != existingItem[CORE_CATEGORY_SPECIFIC_VARS[customizationCategory].CoreReleaseReferenceField]) {
			itemJson[CORE_CATEGORY_SPECIFIC_VARS[customizationCategory].CoreReleaseReferenceField] = releaseId;

			// Update the needs review item and add a log to the changelog.
			changed = true;
			let returnedJsons = markItemAsChanged(itemJson, existingItem, CORE_CATEGORY_SPECIFIC_VARS[customizationCategory].CoreReleaseReferenceField);
			itemJson = returnedJsons[0];
			existingItem = returnedJsons[1];
		}

		if (existingItem[CORE_CATEGORY_SPECIFIC_VARS[customizationCategory].CoreSourceField].includes("(Pending)")) { // If we don't have a source already, we want to update. But only in this case.
			if (customizationDetails.CustomAvailability != null && customizationDetails.CustomAvailability != "") {
				itemJson[CORE_CATEGORY_SPECIFIC_VARS[customizationCategory].CoreSourceField] = customizationDetails.CustomAvailability;
				
				changed = true;
				let returnedJsons = markItemAsChanged(itemJson, existingItem, CORE_CATEGORY_SPECIFIC_VARS[customizationCategory].CoreSourceField);
				itemJson = returnedJsons[0];
				existingItem = returnedJsons[1];
			}
			else if (customizationDetails.RewardTrack != null && customizationDetails.RewardTrack != "") {
				itemJson[CORE_CATEGORY_SPECIFIC_VARS[customizationCategory].CoreSourceField] = customizationDetails.RewardTrack;

				changed = true;
				let returnedJsons = markItemAsChanged(itemJson, existingItem, CORE_CATEGORY_SPECIFIC_VARS[customizationCategory].CoreSourceField);
				itemJson = returnedJsons[0];
				existingItem = returnedJsons[1];
			}
		}

		if (!customizationDetails.HideUntilOwned && existingItem.hidden) {
			itemJson.hidden = customizationDetails.HideUntilOwned; // This addition will allow the automation to show items as they become visible.

			changed = true;
			let returnedJsons = markItemAsChanged(itemJson, existingItem, "hidden");
			itemJson = returnedJsons[0];
			existingItem = returnedJsons[1];
		}

		let newAltText = customizationDetails.Title + " " + siteCustomizationType;
		if (newAltText != existingItem.altText) {
			itemJson.altText = newAltText;

			changed = true;
			let returnedJsons = markItemAsChanged(itemJson, existingItem, "altText");
			itemJson = returnedJsons[0];
			existingItem = returnedJsons[1];
		}

		if (!changed) { // If we didn't make any changes to the item, we can just skip it by returning 1.
			//console.log("No changes needed for ", customizationDetails.Title, " Core. Skipping...");
			return 1;
		}

		itemJsonToInsert = itemJson;

	}
	else { // The item wasn't found, so we need to create a new item.
		//console.log("Adding new item");
		let itemJson = {};

		itemJson.waypointId = customizationDetails.WaypointId; // We're saving the Waypoint ID here.

		// Add the core name.
		itemJson[CORE_CATEGORY_SPECIFIC_VARS[customizationCategory].CoreNameField] = customizationDetails.Title;

		itemJson.image = await getCustomizationImageUrl(folderDict, headers, customizationDetails.Title, customizationDetails.MediaPath, customizationDetails.MimeType, customizationCategory, siteCustomizationType);

		itemJson[CORE_CATEGORY_SPECIFIC_VARS[customizationCategory].CoreQualityReferenceField] = qualityId;
		itemJson[CORE_CATEGORY_SPECIFIC_VARS[customizationCategory].CoreLoreField] = customizationDetails.Description;
		itemJson[CORE_CATEGORY_SPECIFIC_VARS[customizationCategory].CoreManufacturerReferenceField] = manufacturerId;
		itemJson[CORE_CATEGORY_SPECIFIC_VARS[customizationCategory].CoreReleaseReferenceField] = releaseId;

		if (customizationDetails.CustomAvailability != null && customizationDetails.CustomAvailability != "") {
			itemJson[CORE_CATEGORY_SPECIFIC_VARS[customizationCategory].CoreSourceField] = customizationDetails.CustomAvailability;
		}
		else if (customizationDetails.RewardTrack != null && customizationDetails.RewardTrack != "") {
			// TODO: Find an efficient way to read the Battle Pass and update the source accordingly.
			itemJson[CORE_CATEGORY_SPECIFIC_VARS[customizationCategory].CoreSourceField] = customizationDetails.RewardTrack;
		}
		else {
			itemJson[CORE_CATEGORY_SPECIFIC_VARS[customizationCategory].CoreSourceField] = "(Pending)";
		}

		itemJson.currentlyAvailable = false; // This is false by default but may actually need to be manually updated to true.
		itemJson.hidden = customizationDetails.HideUntilOwned;
		itemJson.needsReview = true;
		itemJson.altText = customizationDetails.Title + " " + siteCustomizationType;

		var datetime = getCurrentDateTimeString();
		itemJson.changeLog = [(datetime + ": Added item to DB.")];

		itemJsonToInsert = itemJson;
	}

	return itemJsonToInsert;
}

// This function will convert from waypointJson to the customizationDetails JSON format.
// customizationCategory: One of the accepted category keys.
// waypointJson: The JSON file returned directly from Waypoint.
// waypointThemePathToCoreDict: A dictionary that uses the Waypoint Paths in ParentPaths (which are themes) as keys and returns the names of the associated items.
// attachmentArray: An array of attachment names. Needs to be determined externally due to the information included in the JSON.
// parentWaypointType: The parent type of the item, only used for attachments.
export function getCustomizationDetailsFromWaypointJson(customizationCategory, waypointJson, waypointThemePathToCoreDict=null, attachmentArray=null, parentWaypointType=null) {
	// We want to create this JSON structure:
	/*
		{
			"Title": [itemName],
			"Type": [waypointType],
			"MediaPath": [waypointImagePath],
			"MimeType": [waypointMimeType],
			"Cores": [coreNameArray], // Only available on core-based customizations. Is an array to support cross-core pieces. Will only include "Any" if piece is fully cross-core.
			"Quality": [qualityName],
			"Description": [lore],
			"ManufacturerId": [manufacturerIndex], // The index of the manufacturer when all are listed in alphabetical order.
			"Season": [release],
			"RewardTrack": [waypointPassPath], // This may be null or the empty string. If it exists, it can be used to generate the source.
			"CustomAvailability": [source], // This is almost always null or the empty string.
			"HideUntilOwned": [hidden], // This will usually be honored, except in the case of promo items.
			"Attachments": [attachmentArray] // Contains an array of attachment names that apply to this item. Parent item needs to be added after the attachments are added to the DB.
			"ParentType": [parentWaypointType] // This should only really be used for attachment items.
			"WaypointId": [waypointId]
		}
	*/

	let itemJson = {};
	let waypointCommonDataJson = waypointJson.CommonData;
	itemJson.Title = waypointCommonDataJson.Title;
	itemJson.Type = waypointCommonDataJson.Type;

	let siteType = CUSTOMIZATION_WAYPOINT_TO_SITE_KEYS[customizationCategory][itemJson.Type];

	itemJson.MediaPath = waypointCommonDataJson.DisplayPath.Media.MediaUrl.Path;
	itemJson.MimeType = waypointCommonDataJson.DisplayPath.MimeType;
	if (HAS_CORE_ARRAY.includes(customizationCategory) && !itemJson.Type.includes("Core") && !IS_CROSS_CORE_ARRAY_DICT[customizationCategory].includes(siteType)) { 
		// We don't need to add the Cores field when working with a Core item or a non-core customization category.
		// If the item isn't cross-core, we can't use the "Any" shortcut.
		itemJson.Cores = [];
		if (waypointCommonDataJson.ParentPaths.length > 0) {
			waypointCommonDataJson.ParentPaths.forEach((themePathItem) => {
				if (themePathItem.Path in waypointThemePathToCoreDict && !itemJson.Cores.includes(waypointThemePathToCoreDict[themePathItem.Path])) {
					itemJson.Cores.push(waypointThemePathToCoreDict[themePathItem.Path]);
				}
			});
		}
		else {
			if (waypointCommonDataJson.ParentTheme in waypointThemePathToCoreDict && !itemJson.Cores.includes(waypointThemePathToCoreDict[waypointCommonDataJson.ParentTheme])) {
				itemJson.Cores.push(waypointThemePathToCoreDict[waypointCommonDataJson.ParentTheme]);
			}
			else {
				throw "Item " + itemJson.Title +  " does not have a valid parent core. Skipping for now...";
			}
			
		}

		//console.log("Item: " + itemJson.Title, itemJson.Cores, waypointCommonDataJson.ParentPaths, waypointThemePathToCoreDict);
	}
	else if (HAS_CORE_ARRAY.includes(customizationCategory) && !itemJson.Type.includes("Core") && IS_CROSS_CORE_ARRAY_DICT[customizationCategory].includes(siteType)) {
		// The item type is cross-core, so we just want to use the "Any" shortcut.
		itemJson.Cores = ["Any"];
	}

	itemJson.Quality = waypointCommonDataJson.Quality;
	itemJson.Description = waypointCommonDataJson.Description;
	itemJson.ManufacturerId = waypointCommonDataJson.ManufacturerId;
	itemJson.Season = waypointCommonDataJson.Season;
	itemJson.RewardTrack = waypointCommonDataJson.RewardTrack;
	itemJson.CustomAvailability = waypointCommonDataJson.CustomAvailability;
	itemJson.HideUntilOwned = waypointCommonDataJson.HideUntilOwned;
	itemJson.Attachments = attachmentArray;
	itemJson.ParentType = parentWaypointType;
	itemJson.WaypointId = waypointCommonDataJson.Id;

	return itemJson;
}

// This function accepts a path and other performance variables and performs various tasks to generate an item to insert in the DB. Returns the site JSON for the item (or 1 if item should be skipped, or -1 if error occurred).
// headers: The headers used to access Waypoint endpoints.
// customizationCategory: One of the predefined category keys (e.g. KeyConstants.ARMOR_KEY)
// folderDict: The dictionary representing our media folder path, pregenerated.
// generalDictsAndArrays: The dictionaries and arrays containing prequeried information.
// categorySpecificDictsAndArrays: The dictionaries and array containing prequeried information specific to the customizationCategory.
// itemWaypointPath: The Waypoint path for the item to add.
// itemType: One of four strings: "core", "kit", "item", "attachment"
// coreName: The name of the parent core, if applicable. If "" (default), then no parent core is assumed. Only needed for kits.
// waypointThemePathToCoreDict: A dictionary that takes theme Waypoint paths and converts them to core names.
// coreWaypointJsonArray: An optional array of the Core Waypoint JSONs which will be modified for cores.
// attachmentArray: An array of attachment names for a particular parent item (e.g. Helmet). Should only be nonempty for attachments and items with attachments.
// attachmentPathToNameDict: A dictionary of attachment paths to their corresponding names.
// attachmentParentWaypointType: The parent waypoint type of the attachment item.
async function processItem(headers, customizationCategory, folderDict, generalDictsAndArrays, categorySpecificDictsAndArrays, itemWaypointPath, itemType, itemPathsProcessed, coreName ="", waypointThemePathToCoreDict = {}, coreWaypointJsonArray = [],
	attachmentArray = [], attachmentPathToNameDict = {}, attachmentParentWaypointType = "") {
	// This helps us avoid processing duplicate items.
	if (itemPathsProcessed.includes(itemWaypointPath)) {
		if (itemType == ITEM_TYPES.attachment && !attachmentArray.includes(attachmentPathToNameDict[itemWaypointPath])) { // We still need to add the attachment name to the array if we haven't already.
			attachmentArray.push(attachmentPathToNameDict[itemWaypointPath]);
		}

		return 1;
	}

	itemPathsProcessed.push(itemWaypointPath);
	
	// Get the item.
	let itemWaypointJson = await getCustomizationItem(headers, itemWaypointPath);

	if (itemType == ITEM_TYPES.kit && coreName != "") {
		itemWaypointJson.CommonData.ParentPaths.forEach((waypointCorePath) => { // This is needed to correctly add the core to the item site JSON.
			waypointThemePathToCoreDict[waypointCorePath.Path] = coreName;
		});
	}
	else if (itemType == ITEM_TYPES.attachment) {
		attachmentArray.push(itemWaypointJson.CommonData.Title); // Add the name to the array. TODO: Change to ID.
		attachmentPathToNameDict[itemWaypointPath] = itemWaypointJson.CommonData.Title; // Add the name to the dict as well.
	}

	// Get the details for the core to pass into our site JSON generation function.
	let itemDetails;
	
	itemDetails = getCustomizationDetailsFromWaypointJson(customizationCategory, itemWaypointJson, waypointThemePathToCoreDict, attachmentArray, attachmentParentWaypointType);

	let itemSiteJson;
	
	if (itemType == ITEM_TYPES.core) {
		// If we're working with a core, add the Waypoint JSON to the array, get the site JSON, and add the themes and core name to the dictionary.
		coreWaypointJsonArray.push(itemWaypointJson);

		itemSiteJson = await getCoreItemToSave(folderDict, headers, customizationCategory, itemDetails, generalDictsAndArrays);
	
		itemWaypointJson.Themes.OptionPaths.forEach((waypointThemePath) => {
			waypointThemePathToCoreDict[waypointThemePath] = itemWaypointJson.CommonData.Title;
		});
	}
	else {
		itemSiteJson = await getCustomizationItemToSave(folderDict, headers, customizationCategory, itemDetails, generalDictsAndArrays, categorySpecificDictsAndArrays);
	}

	return itemSiteJson;
}

// This function is going to basically run the getCustomizationItemToSave function repeatedly on each item JSON returned and then save those JSONs to the DB.
// It uses the customizationCategory to get the list of items pertaining to that category.
// The limit applies to each specific Waypoint Group and limits how many items from each theme are processed in this run. The limit is set high by default to encourage explicit use.
// The offset allows us to start further in the list of items at some desired index.
async function updateDbsFromApi(headers, customizationCategory, waypointGroupsToProcess, generalDictsAndArrays, categorySpecificDictsAndArrays, limit=1000, offset=0) {
	let folderDict; // This will be passed to our image grabbing function.
	let results = await wixData.query(KeyConstants.KEY_VALUE_DB) // This might still be a bit inefficient. Consider moving query out and passing folderDict as arg.
		.eq("key", KeyConstants.KEY_VALUE_CUSTOMIZATION_FOLDERS_KEY)
		.find()

	if (results.items.length > 0) {
		folderDict = results.items[0].value;
	}
	else {
		throw "Could not retrieve folder dict. Cannot get customization image urls.";
	}

	switch (customizationCategory) {
		case KeyConstants.ARMOR_KEY:
		case KeyConstants.WEAPON_KEY:
		case KeyConstants.VEHICLE_KEY:
		case KeyConstants.BODY_AND_AI_KEY:
		case KeyConstants.SPARTAN_ID_KEY:
			break;
		default:
			throw "Unable to process customization category " + customizationCategory + " at this time.";
	}

	let coreList = [];
	if (customizationCategory == KeyConstants.ARMOR_KEY) {
		// With armor cores, the JSON returned is in a slightly different format that we need to standardize.
		let armorCoreObjectList = await getArmorCoreList(headers);
		armorCoreObjectList.forEach((armorCoreObject) => {
			coreList.push(armorCoreObject.CoreCMSPath);
		});
	}
	else if (customizationCategory == KeyConstants.WEAPON_KEY || customizationCategory == KeyConstants.VEHICLE_KEY) {
		coreList = await getCoreList(headers, customizationCategory);
	}
	
	let customizationItemDbArray = []; // This will store each item JSON to be added or updated in the DB.

	if (HAS_CORE_ARRAY.includes(customizationCategory)) {
		let coreWaypointJsonArray = [];
		let coreDbJsonArray = [];
		let waypointThemePathToCoreDict = {};
		if (waypointGroupsToProcess.includes("Cores")) {
			// We want to do two things with this iteration: get each JSON for insertion/update into the core DB, and create the waypointThemePathToCoreDict.
			// The keys will be the Waypoint Paths to each child theme, and the values will be the corresponding core name.
			try{
				/*let additionalCorePaths = await Waypoint.getListOfCustomizationPathsByType(customizationCategory + "Core");
				for (let j = 0; j < additionalCorePaths.length; ++j) {
					if (!coreList.includes(additionalCorePaths[j])) {
						console.log("Found additional core: " + additionalCorePaths[j]);
						coreList.push(additionalCorePaths[j]);
					}
				}*/

				let corePathsProcessed = [];

				for (let i = 0; i < coreList.length; i++) {
					try {
						let coreWaypointJson = await getCustomizationItem(headers, coreList[i]);
						coreWaypointJsonArray.push(coreWaypointJson);

						let coreDetails = getCustomizationDetailsFromWaypointJson(customizationCategory, coreWaypointJson);

						let coreSiteJson = await getCoreItemToSave(folderDict, headers, customizationCategory, coreDetails, generalDictsAndArrays);

						coreWaypointJson.Themes.OptionPaths.forEach((waypointThemePath) => {
							waypointThemePathToCoreDict[waypointThemePath] = coreWaypointJson.CommonData.Title;
						});

						if (coreSiteJson == 1) {
							console.log("Skipping " + coreList[i]);
							continue;
						}
						else if (coreSiteJson != -1) {
							coreDbJsonArray.push(coreSiteJson);
						}
						else {
							throw "Error occurred while getting the DB-ready core item JSON.";
						}
					}
					catch (error) {
						console.error("Error ", error, " encountered when trying to add ", coreList[i], "; continuing...");
						continue;
					}
				}
			}
			catch (error) {
				console.error(error);
				// Because we're dealing with modifications to the DB, if we get a major error of any kind, we need to GTFO.
				return -1;
			}

			console.log("After obtaining all Core JSONs: ", coreDbJsonArray);

			// It's time to save the Core entries to the Core DB.
			// This is definitely dangerous, but based on how everything has worked so far, I think we're ready to try it.
			// I absolutely grabbed a backup just in case though.
			// Edit: holy heck it works.
			await wixData.bulkSave(CUSTOMIZATION_CATEGORY_SPECIFIC_VARS[customizationCategory].CoreDb, coreDbJsonArray)
				.then((results) => {
					console.log("After Core DB Save: " + results.inserted + " inserted, " + results.updated + " updated, " + results.skipped + " skipped.");
					console.log("Inserted IDs: " + results.insertedItemIds);
					console.log("Updated IDs: " + results.updatedItemIds);
					if (results.errors.length > 0) {
						console.error("Errors: " + results.errors);
					}
				})
				.catch((error) => {
					console.error(error);
				});

			return 0; // We only want to process Cores, so we get out when we're done.
		}
		else { // If we don't want to add the cores, we just need to get the array of core JSONs.
			for (let i = 0; i < coreList.length; i++) {
				try {
					let coreWaypointJson = await getCustomizationItem(headers, coreList[i]);
					coreWaypointJsonArray.push(coreWaypointJson);
					coreWaypointJson.Themes.OptionPaths.forEach((waypointThemePath) => {
							waypointThemePathToCoreDict[waypointThemePath] = coreWaypointJson.CommonData.Title;
						});
				}
				catch (error) {
					console.error("Error occurred while retrieving core list: " + error);
					return -1;
				}
			}
		}

		// Okay, so now we've gotten all the Cores added. Next, we need to grab each theme, listed in the Themes.OptionPaths array for each core, and check if it's a Kit. If it is, we treat it like an item.
		// Otherwise, we pull its constituent parts out and treat each of those as an item. There's an easy way to check this with the IsKit field.
		
		let customizationItemPathsProcessed = []; // If we already have a path in this array, we don't need to process it again.
		//let kitPathsProcessed = [];

		try{
			for (let i = 0; i < coreWaypointJsonArray.length; i++) {
				let coreName = coreWaypointJsonArray[i].CommonData.Title; // We need to store the core name for future use.
				let themePathArray = coreWaypointJsonArray[i].Themes.OptionPaths;
				
				for (let j = 0; j < themePathArray.length; j++) { // For each theme.

					let themeWaypointJson = await getCustomizationItem(headers, themePathArray[j]);

					if (themeWaypointJson.IsKit) { // Either we have a Kit or the default theme. If it's a kit, we just treat it like any other item.
						try {
							if (!waypointGroupsToProcess.includes("Kits")) { // Skip the Kits if we aren't working on them.
								continue;
							}

							if (customizationItemPathsProcessed.includes(themePathArray[j])) { // If we already have the path in the array, we've processed this already. No need to do it twice.
								continue;
							}

							customizationItemPathsProcessed.push(themePathArray[j]); // Add this path to the array so we don't process it again.

							//kitPathsProcessed.push(themePathArray[j]); // Record that this path is a Kit.

							themeWaypointJson.CommonData.ParentPaths.forEach((waypointCorePath) => { // This is needed to correctly add the core to the JSON.
								waypointThemePathToCoreDict[waypointCorePath.Path] = coreName;
							});

							// We need to get the Kit details, then grab the JSON representing the database item for the kit.
							let kitDetails = getCustomizationDetailsFromWaypointJson(customizationCategory, themeWaypointJson, waypointThemePathToCoreDict);
							let kitDbJson = await getCustomizationItemToSave(folderDict, headers, customizationCategory, kitDetails, generalDictsAndArrays, categorySpecificDictsAndArrays);

							if (kitDbJson == 1) {
								console.log("Skipping " + themePathArray[j]);
								continue;
							}
							else if (kitDbJson != -1) {
								customizationItemDbArray.push(kitDbJson);
							}
							else {
								throw "Error occurred while getting the DB-ready kit item JSON for " + themeWaypointJson.CommonData.Title;
							}
						}
						catch (error) {
							console.error("Error ", error, " encountered when trying to add ", themePathArray[j], "; continuing...");
							continue;
						}
					}
					else { // This is the default theme. We want to iterate over each of its sub items. These are defined in a constant.
						
						if (customizationItemPathsProcessed.includes(themePathArray[j])) { // If we already have the path in the array, we've processed this already. No need to do it twice.
							continue;
						}
						customizationItemPathsProcessed.push(themePathArray[j]); // Add this path to the array so we don't process it again.

						for (let waypointTypeGroup in CUSTOMIZATION_WAYPOINT_GROUP_TYPES[customizationCategory]) {
							if (!waypointGroupsToProcess.includes(waypointTypeGroup)) { // We're adding the ability to only process some of the items.
								continue;
							}

							if (!CUSTOMIZATION_WAYPOINT_GROUP_TYPES[customizationCategory][waypointTypeGroup]) { 
								// Basically, if we aren't working with an attachment-supporting group.
								// We grab the array of waypoint paths, then process each one (so many nested for loops...)
								let customizationItemPathArray = themeWaypointJson[waypointTypeGroup].OptionPaths;

								let processedIterations = 0; // This allows us to count how many iterations actually generate an itemJson and only process a certain number in this attempt.
								for (let k = 0; k < customizationItemPathArray.length; ++k) {
									try {
										let itemPath = customizationItemPathArray[k];
										// This is the path to an individual item JSON now.
										if (customizationItemPathsProcessed.includes(itemPath)) { // If we already have the path in the array, we've processed this already. No need to do it twice.
											continue;
										}

										/*if (!((processedIterations++ - offset) >= 0 && (processedIterations - offset) < limit)) { // I threw the postfix increment in to evaluate even if no processing is done.
											continue;
										}*/

										customizationItemPathsProcessed.push(itemPath); // Add this path to the array so we don't process it again.

										let itemJson = await getCustomizationItem(headers, itemPath);

										// We need to get the item details, then grab the JSON representing the database item.
										let itemDetails = getCustomizationDetailsFromWaypointJson(customizationCategory, itemJson, waypointThemePathToCoreDict);
										let itemDbJson = await getCustomizationItemToSave(folderDict, headers, customizationCategory, itemDetails, generalDictsAndArrays, categorySpecificDictsAndArrays);

										if (itemDbJson == 1) {
											console.log("Skipping " + itemPath);
											continue;
										}
										else if (itemDbJson != -1) {
											customizationItemDbArray.push(itemDbJson);
										}
										else {
											throw "Error occurred while getting the DB-ready item JSON for " + itemJson.CommonData.Title;
										}
									}
									catch (error) {
										console.error("Error ", error, " encountered when trying to add ", customizationItemPathArray[k], "; continuing...");
										continue;
									}
								}
							}
							else {
								// We're working with an item type that has attachments. This means it's laid out a little differently. 
								// Before we can fetch the item details, we have to add the attachments to the DB. This is a little hacky, but what isn't at this point?
								// We'll generate a dictionary where the path of each item points to an array of attachment names.
								// Once we have that dictionary completed and all the attachment items added to their DB, we can proceed to work on the helmets.
								let parentPathToAttachmentArrayDict = {}; // The key of this dict will be the path to the attachment parent item, and its value will be an array of attachment names.
								let itemAndAttachmentsArray = themeWaypointJson[waypointTypeGroup]["Options"];
								let attachmentPathToNameDict = {}; // The keys will be attachment paths and the values will be the corresponding names.
								let customizationItemAttachmentPathsProcessed = []; // As long as we can tie the attachment path to a name, we don't have to process a path twice.
								let customizationItemAttachmentDbArray = []; // These are stored in a separate DB and can't be added with the regular ones.

								for (let l = 0; l < itemAndAttachmentsArray.length; ++l) {
									let attachmentParentPath = itemAndAttachmentsArray[l].HelmetPath; // TODO: Make this work for other attachments if they get added.
									let parentWaypointType = "ArmorHelmet";
									let attachmentArray = []; // This is an array of attachment names specifically meant for the parentPathToAttachmentArrayDict.
									for (let m = 0; m < itemAndAttachmentsArray[l].HelmetAttachments.OptionPaths.length; ++m) {
										try {
											let attachmentPath = itemAndAttachmentsArray[l].HelmetAttachments.OptionPaths[m];
											if (customizationItemAttachmentPathsProcessed.includes(attachmentPath)) { // Don't process a path more than necessary. We know what's at the end of this one.
												if (!attachmentArray.includes(attachmentPathToNameDict[attachmentPath])) { // We still need to add the attachment name to the array if we haven't already.
													attachmentArray.push(attachmentPathToNameDict[attachmentPath]);
												}
												continue;
											}
											// As long as we map the attachmentPath to the name, we can just process a path once.
											customizationItemAttachmentPathsProcessed.push(attachmentPath);

											let attachmentJson = await getCustomizationItem(headers, attachmentPath); // The attachment JSON straight from Waypoint.
											attachmentArray.push(attachmentJson.CommonData.Title); // Add the name to the array.
											attachmentPathToNameDict[attachmentPath] = attachmentJson.CommonData.Title; // Add the name to the dict as well.

											// We need to get the item details, then grab the JSON representing the database item.
											let attachmentDetails = getCustomizationDetailsFromWaypointJson(KeyConstants.ARMOR_ATTACHMENT_KEY, attachmentJson, waypointThemePathToCoreDict, null, parentWaypointType);
											let attachmentDbJson = await getCustomizationItemToSave(folderDict, headers, KeyConstants.ARMOR_ATTACHMENT_KEY, attachmentDetails, generalDictsAndArrays, categorySpecificDictsAndArrays);

											if (attachmentDbJson == 1) {
												console.log("Skipping " + attachmentPath);
												continue;
											}
											else if (attachmentDbJson != -1) {
												customizationItemAttachmentDbArray.push(attachmentDbJson);
											}
											else {
												throw "Error occurred while getting the DB-ready item JSON for " + attachmentJson.CommonData.Title;
											}
										}
										catch (error) {
											console.error("Error ", error, " encountered when trying to add ", itemAndAttachmentsArray[l].HelmetAttachments.OptionPaths[m], "; continuing...");
											continue;
										}
									}

									// Now that we've got all the attachment names for the item in an array, let's add it to the dictionary.
									parentPathToAttachmentArrayDict[attachmentParentPath] = attachmentArray;
								}

								// Time to check our work I guess
								//console.log("Parent Path to Attachment Array Dict Contents: ", parentPathToAttachmentArrayDict);
								//console.log("After obtaining all Attachment JSONs for " + coreName + ": ", customizationItemAttachmentDbArray);

								// Work has been checked! Let's proceed to add the attachments.
								await wixData.bulkSave(KeyConstants.ARMOR_CUSTOMIZATION_ATTACHMENTS_DB, customizationItemAttachmentDbArray)
									.then((results) => {
										console.log("After Armor Customization DB Save: " + results.inserted + " inserted, " + results.updated + " updated, " + results.skipped + " skipped.");
										
										if (results.insertedItemIds.length > 0) {
											console.log("Inserted IDs: " + results.insertedItemIds);
										}
										
										if (results.updatedItemIds.length > 0)	{
											console.log("Updated IDs: " + results.updatedItemIds);
										}

										if (results.errors.length > 0) {
											console.error("Errors: " + results.errors);
										}
									})
									.catch( (error) => {
										console.error(error);
									});

								// Now that the attachments have been added, we need to go back through and add the helmets as expected.
								for (let l = 0; l < itemAndAttachmentsArray.length; ++l) {
									try {
										let itemPath = itemAndAttachmentsArray[l].HelmetPath;
										// This is the path to an individual item JSON now.
										if (customizationItemPathsProcessed.includes(itemPath)) { // If we already have the path in the array, we've processed this already. No need to do it twice.
											continue;
										}

										/*if (!((processedIterations++ - offset) >= 0 && (processedIterations - offset) < limit)) { // I threw the postfix increment in to evaluate even if no processing is done.
											continue;
										}*/

										customizationItemPathsProcessed.push(itemPath); // Add this path to the array so we don't process it again.

										let itemJson = await getCustomizationItem(headers, itemPath);

										// We need to get the item details, then grab the JSON representing the database item. Since this has attachments, we need to create it with the attachment array.
										let itemDetails = getCustomizationDetailsFromWaypointJson(customizationCategory, itemJson, waypointThemePathToCoreDict, parentPathToAttachmentArrayDict[itemPath]);
										let itemDbJson = await getCustomizationItemToSave(folderDict, headers, customizationCategory, itemDetails, generalDictsAndArrays, categorySpecificDictsAndArrays);

										if (itemDbJson == 1) {
											console.log("Skipping " + itemPath);
											continue;
										}
										else if (itemDbJson != -1) {
											customizationItemDbArray.push(itemDbJson);
										}
										else {
											throw "Error occurred while getting the DB-ready item JSON for " + itemJson.CommonData.Title;
										}
									}
									catch (error) {
										console.error("Error ", error, " encountered when trying to add ", itemAndAttachmentsArray[l].HelmetPath, "; continuing...");
										continue;
									}
								}

							}
						}
					}
				}
			}

			// We should now process any remaining themes and items. EDIT: Not going to do this after all. Too much garbage was getting imported.
			/*let additionalThemePaths = await Waypoint.getListOfCustomizationPathsByType(customizationCategory + "Theme");
			for (let j = 0; j < additionalThemePaths.length; ++j) {
				if (customizationItemPathsProcessed.includes(additionalThemePaths[j])) { // If we already have the path in the array, we've processed this already. No need to do it twice.
					continue;
				}

				console.log("Found additional theme: " + additionalThemePaths[j]);
				customizationItemPathsProcessed.push(additionalThemePaths[j]); // Add this path to the array so we don't process it again.

				let themeWaypointJson = await getCustomizationItem(headers, additionalThemePaths[j]);

				if (themeWaypointJson.IsKit) { // Either we have a Kit or the default theme. If it's a kit, we just treat it like any other item.
					try {
						kitPathsProcessed.push(additionalThemePaths[j]);

						if (!waypointGroupsToProcess.includes("Kits")) { // Skip the Kits if we aren't working on them.
							continue;
						}

						// We need to get the Kit details, then grab the JSON representing the database item for the kit.
						let kitDetails = getCustomizationDetailsFromWaypointJson(customizationCategory, themeWaypointJson, waypointThemePathToCoreDict);
						let kitDbJson = await getCustomizationItemToSave(folderDict, headers, customizationCategory, kitDetails, generalDictsAndArrays, categorySpecificDictsAndArrays);

						if (kitDbJson == 1) {
							console.log("Skipping " + additionalThemePaths[j]);
							continue;
						}
						else if (kitDbJson != -1) {
							customizationItemDbArray.push(kitDbJson);
						}
						else {
							throw "Error occurred while getting the DB-ready kit item JSON for " + themeWaypointJson.CommonData.Title;
						}
					}
					catch (error) {
						console.error("Error ", error, " encountered when trying to add ", additionalThemePaths[j], "; continuing...");
						continue;
					}
				}
				else { // This is the default theme. We want to iterate over each of its sub items. These are defined in a constant.
					for (let waypointTypeGroup in CUSTOMIZATION_WAYPOINT_GROUP_TYPES[customizationCategory]) {
						if (!waypointGroupsToProcess.includes(waypointTypeGroup)) { // We're adding the ability to only process some of the items.
							continue;
						}

						if (!CUSTOMIZATION_WAYPOINT_GROUP_TYPES[customizationCategory][waypointTypeGroup]) { 
							// Basically, if we aren't working with an attachment-supporting group.
							// We grab the array of waypoint paths, then process each one (so many nested for loops...)
							let customizationItemPathArray = themeWaypointJson[waypointTypeGroup].OptionPaths;

							let processedIterations = 0; // This allows us to count how many iterations actually generate an itemJson and only process a certain number in this attempt.
							for (let k = 0; k < customizationItemPathArray.length; ++k) {
								try {
									let itemPath = customizationItemPathArray[k];
									// This is the path to an individual item JSON now.
									if (customizationItemPathsProcessed.includes(itemPath)) { // If we already have the path in the array, we've processed this already. No need to do it twice.
										continue;
									}

									/*if (!((processedIterations++ - offset) >= 0 && (processedIterations - offset) < limit)) { // I threw the postfix increment in to evaluate even if no processing is done.
										continue;
									}

									customizationItemPathsProcessed.push(itemPath); // Add this path to the array so we don't process it again.

									let itemJson = await getCustomizationItem(headers, itemPath);

									// We need to get the item details, then grab the JSON representing the database item.
									let itemDetails = getCustomizationDetailsFromWaypointJson(customizationCategory, itemJson, waypointThemePathToCoreDict);
									let itemDbJson = await getCustomizationItemToSave(folderDict, headers, customizationCategory, itemDetails, generalDictsAndArrays, categorySpecificDictsAndArrays);

									if (itemDbJson == 1) {
										console.log("Skipping " + itemPath);
										continue;
									}
									else if (itemDbJson != -1) {
										customizationItemDbArray.push(itemDbJson);
									}
									else {
										throw "Error occurred while getting the DB-ready item JSON for " + itemJson.CommonData.Title;
									}
								}
								catch (error) {
									console.error("Error ", error, " encountered when trying to add ", customizationItemPathArray[k], "; continuing...");
									continue;
								}
							}
						}
						else {
							// We're working with an item type that has attachments. This means it's laid out a little differently. 
							// Before we can fetch the item details, we have to add the attachments to the DB. This is a little hacky, but what isn't at this point?
							// We'll generate a dictionary where the path of each item points to an array of attachment names.
							// Once we have that dictionary completed and all the attachment items added to their DB, we can proceed to work on the helmets.
							let parentPathToAttachmentArrayDict = {}; // The key of this dict will be the path to the attachment parent item, and its value will be an array of attachment names.
							let itemAndAttachmentsArray = themeWaypointJson[waypointTypeGroup]["Options"];
							let attachmentPathToNameDict = {}; // The keys will be attachment paths and the values will be the corresponding names.
							let customizationItemAttachmentPathsProcessed = []; // As long as we can tie the attachment path to a name, we don't have to process a path twice.
							let customizationItemAttachmentDbArray = []; // These are stored in a separate DB and can't be added with the regular ones.

							for (let l = 0; l < itemAndAttachmentsArray.length; ++l) {
								let attachmentParentPath = itemAndAttachmentsArray[l].HelmetPath; // TODO: Make this work for other attachments if they get added.
								let parentWaypointType = "ArmorHelmet";
								let attachmentArray = []; // This is an array of attachment names specifically meant for the parentPathToAttachmentArrayDict.
								for (let m = 0; m < itemAndAttachmentsArray[l].HelmetAttachments.OptionPaths.length; ++m) {
									try {
										let attachmentPath = itemAndAttachmentsArray[l].HelmetAttachments.OptionPaths[m];
										if (customizationItemAttachmentPathsProcessed.includes(attachmentPath)) { // Don't process a path more than necessary. We know what's at the end of this one.
											if (!attachmentArray.includes(attachmentPathToNameDict[attachmentPath])) { // We still need to add the attachment name to the array if we haven't already.
												attachmentArray.push(attachmentPathToNameDict[attachmentPath]);
											}
											continue;
										}
										// As long as we map the attachmentPath to the name, we can just process a path once.
										customizationItemAttachmentPathsProcessed.push(attachmentPath);

										let attachmentJson = await getCustomizationItem(headers, attachmentPath); // The attachment JSON straight from Waypoint.
										attachmentArray.push(attachmentJson.CommonData.Title); // Add the name to the array.
										attachmentPathToNameDict[attachmentPath] = attachmentJson.CommonData.Title; // Add the name to the dict as well.

										// We need to get the item details, then grab the JSON representing the database item.
										let attachmentDetails = getCustomizationDetailsFromWaypointJson(KeyConstants.ARMOR_ATTACHMENT_KEY, attachmentJson, waypointThemePathToCoreDict, null, parentWaypointType);
										let attachmentDbJson = await getCustomizationItemToSave(folderDict, headers, KeyConstants.ARMOR_ATTACHMENT_KEY, attachmentDetails, generalDictsAndArrays, categorySpecificDictsAndArrays);

										if (attachmentDbJson == 1) {
											console.log("Skipping " + attachmentPath);
											continue;
										}
										else if (attachmentDbJson != -1) {
											customizationItemAttachmentDbArray.push(attachmentDbJson);
										}
										else {
											throw "Error occurred while getting the DB-ready item JSON for " + attachmentJson.CommonData.Title;
										}
									}
									catch (error) {
										console.error("Error ", error, " encountered when trying to add ", itemAndAttachmentsArray[l].HelmetAttachments.OptionPaths[m], "; continuing...");
										continue;
									}
								}

								// Now that we've got all the attachment names for the item in an array, let's add it to the dictionary.
								parentPathToAttachmentArrayDict[attachmentParentPath] = attachmentArray;
							}

							// Time to check our work I guess
							//console.log("Parent Path to Attachment Array Dict Contents: ", parentPathToAttachmentArrayDict);
							//console.log("After obtaining all remaining Attachment JSONs: ", customizationItemAttachmentDbArray);

							// Work has been checked! Let's proceed to add the attachments.
							await wixData.bulkSave(KeyConstants.ARMOR_CUSTOMIZATION_ATTACHMENTS_DB, customizationItemAttachmentDbArray)
								.then((results) => {
									console.log("After Armor Customization DB Save: " + results.inserted + " inserted, " + results.updated + " updated, " + results.skipped + " skipped.");
									
									if (results.insertedItemIds.length > 0) {
										console.log("Inserted IDs: " + results.insertedItemIds);
									}
									
									if (results.updatedItemIds.length > 0)	{
										console.log("Updated IDs: " + results.updatedItemIds);
									}

									if (results.errors.length > 0) {
										console.error("Errors: " + results.errors);
									}
								})
								.catch( (error) => {
									console.error(error);
								});

							// Now that the attachments have been added, we need to go back through and add the helmets as expected.
							for (let l = 0; l < itemAndAttachmentsArray.length; ++l) {
								try {
									let itemPath = itemAndAttachmentsArray[l].HelmetPath;
									// This is the path to an individual item JSON now.
									if (customizationItemPathsProcessed.includes(itemPath)) { // If we already have the path in the array, we've processed this already. No need to do it twice.
										continue;
									}

									/*if (!((processedIterations++ - offset) >= 0 && (processedIterations - offset) < limit)) { // I threw the postfix increment in to evaluate even if no processing is done.
										continue;
									}

									customizationItemPathsProcessed.push(itemPath); // Add this path to the array so we don't process it again.

									let itemJson = await getCustomizationItem(headers, itemPath);

									// We need to get the item details, then grab the JSON representing the database item. Since this has attachments, we need to create it with the attachment array.
									let itemDetails = getCustomizationDetailsFromWaypointJson(customizationCategory, itemJson, waypointThemePathToCoreDict, parentPathToAttachmentArrayDict[itemPath]);
									let itemDbJson = await getCustomizationItemToSave(folderDict, headers, customizationCategory, itemDetails, generalDictsAndArrays, categorySpecificDictsAndArrays);

									if (itemDbJson == 1) {
										console.log("Skipping " + itemPath);
										continue;
									}
									else if (itemDbJson != -1) {
										customizationItemDbArray.push(itemDbJson);
									}
									else {
										throw "Error occurred while getting the DB-ready item JSON for " + itemJson.CommonData.Title;
									}
								}
								catch (error) {
									console.error("Error ", error, " encountered when trying to add ", itemAndAttachmentsArray[l].HelmetPath, "; continuing...");
									continue;
								}
							}

						}
					}
				}
			}

			for (let waypointTypeGroup in CUSTOMIZATION_WAYPOINT_GROUP_TYPES[customizationCategory]) {
				if (!waypointGroupsToProcess.includes(waypointTypeGroup)) { // We're adding the ability to only process some of the items.
					continue;
				}
				// We grab the array of waypoint paths, then process each one (so many nested for loops...)
				let customizationItemPathArray = await Waypoint.getListOfCustomizationPathsByType(CUSTOMIZATION_WAYPOINT_GROUP_TYPE_TO_WAYPOINT_TYPE[customizationCategory][waypointTypeGroup]);

				let processedIterations = 0; // This allows us to count how many iterations actually generate an itemJson and only process a certain number in this attempt.
				for (let k = 0; k < customizationItemPathArray.length; ++k) {
					try {
						let itemPath = customizationItemPathArray[k];
						// This is the path to an individual item JSON now.
						if (customizationItemPathsProcessed.includes(itemPath)) { // If we already have the path in the array, we've processed this already. No need to do it twice.
							continue;
						}

						console.log("Found additional " + CUSTOMIZATION_WAYPOINT_GROUP_TYPE_TO_WAYPOINT_TYPE[customizationCategory][waypointTypeGroup] + ": " + customizationItemPathArray[k]);

						/*if (!((processedIterations++ - offset) >= 0 && (processedIterations - offset) < limit)) { // I threw the postfix increment in to evaluate even if no processing is done.
							continue;
						}

						customizationItemPathsProcessed.push(itemPath); // Add this path to the array so we don't process it again.

						let itemJson = await getCustomizationItem(headers, itemPath);

						let skipItem = false;

						itemJson.CommonData.ParentPaths.forEach((parentPathObject) => { // This logic lets us skip items that are part of a Kit. It's not perfect, but it will do for now.
							// TODO: Remove this once Kit items can be processed.
							if (kitPathsProcessed.includes(parentPathObject.Path)) {
								skipItem = true;
							}
						});

						if (skipItem) {
							continue;
						}

						// We need to get the item details, then grab the JSON representing the database item.
						let itemDetails = getCustomizationDetailsFromWaypointJson(customizationCategory, itemJson, waypointThemePathToCoreDict);
						let itemDbJson = await getCustomizationItemToSave(folderDict, headers, customizationCategory, itemDetails, generalDictsAndArrays, categorySpecificDictsAndArrays);

						if (itemDbJson == 1) {
							console.log("Skipping " + itemPath);
							continue;
						}
						else if (itemDbJson != -1) {
							customizationItemDbArray.push(itemDbJson);
						}
						else {
							throw "Error occurred while getting the DB-ready item JSON for " + itemJson.CommonData.Title;
						}
					}
					catch (error) {
						console.error("Error ", error, " encountered when trying to add ", customizationItemPathArray[k], "; continuing...");
						continue;
					}
				}
			}*/

			//console.log("After obtaining all JSONs for these Waypoint Groups: ", waypointGroupsToProcess, ", we got this Array: ", customizationItemDbArray);
		}
		catch (error) {
			console.error(error);
			// Because we're dealing with modifications to the DB, if we get an error of any kind, we need to GTFO.
			return -1;
		}
	}
	else if (customizationCategory != KeyConstants.SPARTAN_ID_KEY) { // For right now, this case only applies to Body & AI, but it could also apply to other customization categories in the future.
		let themePathArray = await getThemeList(headers, customizationCategory);
		let customizationItemPathsProcessed = []; // If we already have a path in this array, we don't need to process it again.

		/*let additionalThemePaths = await Waypoint.getListOfCustomizationPathsByType(customizationCategory + "Theme");
		for (let j = 0; j < additionalThemePaths.length; ++j) {
			if (!themePathArray.includes(additionalThemePaths[j])) {
				console.log("Found additional theme: " + additionalThemePaths[j]);
				themePathArray.push(additionalThemePaths[j]);
			}
		}*/

		for (let j = 0; j < themePathArray.length; j++) { // For each theme.
			if (customizationItemPathsProcessed.includes(themePathArray[j])) { // If we already have the path in the array, we've processed this already. No need to do it twice.
				continue;
			}
			customizationItemPathsProcessed.push(themePathArray[j]); // Add this path to the array so we don't process it again.

			let themeWaypointJson = await getCustomizationItem(headers, themePathArray[j]);

			if (themeWaypointJson.IsKit) { // Either we have a Kit or the default theme. If it's a kit, we just treat it like any other item.
				try {
					if (!waypointGroupsToProcess.includes("Kits")) { // Skip the Kits if we aren't working on them.
						continue;
					}

					// We need to get the Kit details, then grab the JSON representing the database item for the kit.
					let kitDetails = getCustomizationDetailsFromWaypointJson(customizationCategory, themeWaypointJson);
					let kitDbJson = await getCustomizationItemToSave(folderDict, headers, customizationCategory, kitDetails, generalDictsAndArrays, categorySpecificDictsAndArrays);

					if (kitDbJson == 1) {
						console.log("Skipping " + themePathArray[j]);
						continue;
					}
					else if (kitDbJson != -1) {
						customizationItemDbArray.push(kitDbJson);
					}
					else {
						throw "Error occurred while getting the DB-ready kit item JSON for " + themeWaypointJson.CommonData.Title;
					}
				}
				catch (error) {
					console.error("Error ", error, " encountered when trying to add ", themePathArray[j], "; continuing...");
					continue;
				}
			}
			else { // This is the default theme. We want to iterate over each of its sub items. These are defined in a constant.
				for (let waypointTypeGroup in CUSTOMIZATION_WAYPOINT_GROUP_TYPES[customizationCategory]) {
					if (!waypointGroupsToProcess.includes(waypointTypeGroup)) { // We're adding the ability to only process some of the items.
						continue;
					}

					if (!CUSTOMIZATION_WAYPOINT_GROUP_TYPES[customizationCategory][waypointTypeGroup]) { 
						// Basically, if we aren't working with an attachment-supporting group. Should always be the case for now.
						// We grab the array of waypoint paths, then process each one (so many nested for loops...)
						let customizationItemPathArray = themeWaypointJson[waypointTypeGroup].OptionPaths;
						let processedIterations = 0; // This allows us to count how many iterations actually generate an itemJson and only process a certain number in this attempt.

						/*let additionalItemPaths = await Waypoint.getListOfCustomizationPathsByType(CUSTOMIZATION_WAYPOINT_GROUP_TYPE_TO_WAYPOINT_TYPE[customizationCategory][waypointTypeGroup]);
						for (let k = 0; k < additionalItemPaths.length; ++k) {
							if (!customizationItemPathArray.includes(additionalItemPaths[k])) {
								console.log("Found additional " + CUSTOMIZATION_WAYPOINT_GROUP_TYPE_TO_WAYPOINT_TYPE[customizationCategory][waypointTypeGroup] + ": " + additionalItemPaths[k]);
								customizationItemPathArray.push(additionalItemPaths[k]);
							}
						}*/

						for (let k = 0; k < customizationItemPathArray.length; ++k) {
							try {
								let itemPath = customizationItemPathArray[k];
								// This is the path to an individual item JSON now.
								if (customizationItemPathsProcessed.includes(itemPath)) { // If we already have the path in the array, we've processed this already. No need to do it twice.
									continue;
								}

								/*if (!((processedIterations++ - offset) >= 0 && (processedIterations - offset) < limit)) { // I threw the postfix increment in to evaluate even if no processing is done.
									continue;
								}*/

								customizationItemPathsProcessed.push(itemPath); // Add this path to the array so we don't process it again.

								let itemJson = await getCustomizationItem(headers, itemPath);

								// We need to get the item details, then grab the JSON representing the database item.
								let itemDetails = getCustomizationDetailsFromWaypointJson(customizationCategory, itemJson);
								let itemDbJson = await getCustomizationItemToSave(folderDict, headers, customizationCategory, itemDetails, generalDictsAndArrays, categorySpecificDictsAndArrays);

								if (itemDbJson == 1) {
									console.log("Skipping " + itemPath);
									continue;
								}
								else if (itemDbJson != -1) {
									customizationItemDbArray.push(itemDbJson);
								}
								else {
									throw "Error occurred while getting the DB-ready item JSON for " + itemJson.CommonData.Title;
								}
							}
							catch (error) {
								console.error("Error ", error, " encountered when trying to add ", customizationItemPathArray[k], "; continuing...");
								continue;
							}
						}
					}
					else {
						// We're working with an item type that has attachments. This means it's laid out a little differently. 
						// Before we can fetch the item details, we have to add the attachments to the DB. This is a little hacky, but what isn't at this point?
						// We'll generate a dictionary where the path of each item points to an array of attachment names.
						// Once we have that dictionary completed and all the attachment items added to their DB, we can proceed to work on the helmets.
						let parentPathToAttachmentArrayDict = {}; // The key of this dict will be the path to the attachment parent item, and its value will be an array of attachment names.
						let itemAndAttachmentsArray = themeWaypointJson[waypointTypeGroup]["Options"];
						let attachmentPathToNameDict = {}; // The keys will be attachment paths and the values will be the corresponding names.
						let customizationItemAttachmentPathsProcessed = []; // As long as we can tie the attachment path to a name, we don't have to process a path twice.
						let customizationItemAttachmentDbArray = []; // These are stored in a separate DB and can't be added with the regular ones.

						for (let l = 0; l < itemAndAttachmentsArray.length; ++l) {
							let attachmentParentPath = itemAndAttachmentsArray[l].HelmetPath; // TODO: Make this work for other attachments if they get added.
							let parentWaypointType = "ArmorHelmet";
							let attachmentArray = []; // This is an array of attachment names specifically meant for the parentPathToAttachmentArrayDict.
							for (let m = 0; m < itemAndAttachmentsArray[l].HelmetAttachments.OptionPaths.length; ++m) {
								try {
									let attachmentPath = itemAndAttachmentsArray[l].HelmetAttachments.OptionPaths[m];
									if (customizationItemAttachmentPathsProcessed.includes(attachmentPath)) { // Don't process a path more than necessary. We know what's at the end of this one.
										if (!attachmentArray.includes(attachmentPathToNameDict[attachmentPath])) { // We still need to add the attachment name to the array if we haven't already.
											attachmentArray.push(attachmentPathToNameDict[attachmentPath]);
										}
										continue;
									}
									// As long as we map the attachmentPath to the name, we can just process a path once.
									customizationItemAttachmentPathsProcessed.push(attachmentPath);

									let attachmentJson = await getCustomizationItem(headers, attachmentPath); // The attachment JSON straight from Waypoint.
									attachmentArray.push(attachmentJson.CommonData.Title); // Add the name to the array.
									attachmentPathToNameDict[attachmentPath] = attachmentJson.CommonData.Title; // Add the name to the dict as well.

									// We need to get the item details, then grab the JSON representing the database item.
									let attachmentDetails = getCustomizationDetailsFromWaypointJson(KeyConstants.ARMOR_ATTACHMENT_KEY, attachmentJson, null, null, parentWaypointType);
									let attachmentDbJson = await getCustomizationItemToSave(folderDict, headers, KeyConstants.ARMOR_ATTACHMENT_KEY, attachmentDetails, generalDictsAndArrays, categorySpecificDictsAndArrays);

									if (attachmentDbJson == 1) {
										console.log("Skipping " + attachmentPath);
										continue;
									}
									else if (attachmentDbJson != -1) {
										customizationItemAttachmentDbArray.push(attachmentDbJson);
									}
									else {
										throw "Error occurred while getting the DB-ready item JSON for " + attachmentJson.CommonData.Title;
									}
								}
								catch (error) {
									console.error("Error ", error, " encountered when trying to add ", itemAndAttachmentsArray[l].HelmetAttachments.OptionPaths[m], "; continuing...");
									continue;
								}
							}

							// Now that we've got all the attachment names for the item in an array, let's add it to the dictionary.
							parentPathToAttachmentArrayDict[attachmentParentPath] = attachmentArray;
						}

						// Time to check our work I guess
						//console.log("Parent Path to Attachment Array Dict Contents: ", parentPathToAttachmentArrayDict);
						//console.log("After obtaining all Attachment JSONs for " + customizationCategory + ": ", customizationItemAttachmentDbArray);

						// Work has been checked! Let's proceed to add the attachments.
						await wixData.bulkSave(KeyConstants.ARMOR_CUSTOMIZATION_ATTACHMENTS_DB, customizationItemAttachmentDbArray)
							.then((results) => {
								console.log("After " + customizationCategory + "Attachments DB Save: " + results.inserted + " inserted, " + results.updated + " updated, " + results.skipped + " skipped.");
								
								if (results.insertedItemIds.length > 0) {
									console.log("Inserted IDs: " + results.insertedItemIds);
								}
								
								if (results.updatedItemIds.length > 0)	{
									console.log("Updated IDs: " + results.updatedItemIds);
								}

								if (results.errors.length > 0) {
									console.error("Errors: " + results.errors);
								}
							})
							.catch( (error) => {
								console.error(error);
							});

						// Now that the attachments have been added, we need to go back through and add the helmets as expected.
						for (let l = 0; l < itemAndAttachmentsArray.length; ++l) {
							try {
								let itemPath = itemAndAttachmentsArray[l].HelmetPath;
								// This is the path to an individual item JSON now.
								if (customizationItemPathsProcessed.includes(itemPath)) { // If we already have the path in the array, we've processed this already. No need to do it twice.
									continue;
								}

								/*if (!((processedIterations++ - offset) >= 0 && (processedIterations - offset) < limit)) { // I threw the postfix increment in to evaluate even if no processing is done.
									continue;
								}*/

								customizationItemPathsProcessed.push(itemPath); // Add this path to the array so we don't process it again.

								let itemJson = await getCustomizationItem(headers, itemPath);

								// We need to get the item details, then grab the JSON representing the database item. Since this has attachments, we need to create it with the attachment array.
								let itemDetails = getCustomizationDetailsFromWaypointJson(customizationCategory, itemJson, null, parentPathToAttachmentArrayDict[itemPath]);
								let itemDbJson = await getCustomizationItemToSave(folderDict, headers, customizationCategory, itemDetails, generalDictsAndArrays, categorySpecificDictsAndArrays);

								if (itemDbJson == 1) {
									console.log("Skipping " + itemPath);
									continue;
								}
								else if (itemDbJson != -1) {
									customizationItemDbArray.push(itemDbJson);
								}
								else {
									throw "Error occurred while getting the DB-ready item JSON for " + itemJson.CommonData.Title;
								}
							}
							catch (error) {
								console.error("Error ", error, " encountered when trying to add ", itemAndAttachmentsArray[l].HelmetPath, "; continuing...");
								continue;
							}
						}

					}
				}
			}
		}
	}
	else { // This applies for theme-less customization categories (e.g. Spartan ID).
		let customizationItemPathArray = await getSpartanIdPathList(headers);
		let customizationItemPathsProcessed = [];

		let spartanIdWaypointTypes = ["SpartanActionPose", "SpartanBackdropImage", "SoartanEmblem", "SpartanStance"];
		/*for (let i = 0; i < spartanIdWaypointTypes.length; ++i) {
			let additionalItemPaths = await Waypoint.getListOfCustomizationPathsByType(spartanIdWaypointTypes[i]);
			for (let k = 0; k < additionalItemPaths.length; ++k) {
				if (!customizationItemPathArray.includes(additionalItemPaths[k])) {
					console.log("Found additional " + spartanIdWaypointTypes[i] + ": " + additionalItemPaths[k]);
					customizationItemPathArray.push(additionalItemPaths[k]);
				}
			}
		}*/

		for (let k = 0; k < customizationItemPathArray.length; ++k) {
			try {
				let itemPath = customizationItemPathArray[k];
				// This is the path to an individual item JSON now.
				if (customizationItemPathsProcessed.includes(itemPath)) { // If we already have the path in the array, we've processed this already. No need to do it twice.
					continue;
				}

				/*if (!((processedIterations++ - offset) >= 0 && (processedIterations - offset) < limit)) { // I threw the postfix increment in to evaluate even if no processing is done.
					continue;
				}*/

				customizationItemPathsProcessed.push(itemPath); // Add this path to the array so we don't process it again.

				let itemJson = await getCustomizationItem(headers, itemPath);

				// We need to get the item details, then grab the JSON representing the database item.
				let itemDetails = getCustomizationDetailsFromWaypointJson(customizationCategory, itemJson);
				let itemDbJson = await getCustomizationItemToSave(folderDict, headers, customizationCategory, itemDetails, generalDictsAndArrays, categorySpecificDictsAndArrays);

				if (itemDbJson == 1) {
					console.log("Skipping " + itemPath);
					continue;
				}
				else if (itemDbJson != -1) {
					customizationItemDbArray.push(itemDbJson);
				}
				else {
					throw "Error occurred while getting the DB-ready item JSON for " + itemJson.CommonData.Title;
				}
			}
			catch (error) {
				console.error("Error ", error, " encountered when trying to add ", customizationItemPathArray[k], "; continuing...");
				continue;
			}
		}

	}
	// It's time to save the entries to the Customization DB.
	// This is definitely dangerous, but based on how everything has worked so far, I think we're ready to try it.
	// This is absolutely terrifying, but thankfully I made a backup of everything...
	// We also have to insert the core and attachment multi-references separately if they exist. (Sad boi hours...)
	let coreReferenceField = CUSTOMIZATION_CATEGORY_SPECIFIC_VARS[customizationCategory].CustomizationCoreReferenceField;
	let attachmentReferenceField = CUSTOMIZATION_CATEGORY_SPECIFIC_VARS[customizationCategory].CustomizationAttachmentReferenceField;

	console.log("All items found for " + customizationCategory + " and groups", waypointGroupsToProcess);

	for (let i = 0; i < customizationItemDbArray.length; ++i) {
		let options = {
			"suppressAuth": true,
			"suppressHooks": true
		};

		let customizationItemDbJson = customizationItemDbArray[i];

		let itemCopy = JSON.parse(JSON.stringify(customizationItemDbJson)); // The save function replaces these JSONs! WTF? Need to make a deep copy.

		wixData.save(CUSTOMIZATION_CATEGORY_SPECIFIC_VARS[customizationCategory].CustomizationDb, itemCopy, options)
			.then ((item) => {

				console.log("Item added or updated: ", customizationItemDbJson);
				if (HAS_CORE_ARRAY.includes(customizationCategory) && coreReferenceField in customizationItemDbJson) {
					console.log("Adding core references for " + customizationItemDbJson[CUSTOMIZATION_CATEGORY_SPECIFIC_VARS[customizationCategory].CustomizationNameField]);
					wixData.replaceReferences(CUSTOMIZATION_CATEGORY_SPECIFIC_VARS[customizationCategory].CustomizationDb, coreReferenceField, item._id, customizationItemDbJson[coreReferenceField], options)
						.then(() => {
							console.log("Core references added for ", customizationItemDbJson[CUSTOMIZATION_CATEGORY_SPECIFIC_VARS[customizationCategory].CustomizationNameField]);
						})
						.catch((error) => {
							console.error("Error ", error, " occurred when replacing core references for ", item._id, " in ", KeyConstants.ARMOR_CUSTOMIZATION_DB, 
								" with ", customizationItemDbJson[coreReferenceField]);
						});
				}
				else {
					console.log("The item ", customizationItemDbJson, " does not seem to contain " + coreReferenceField);
				}

				if ((customizationCategory in CUSTOMIZATION_TYPES_WITH_ATTACHMENTS) && attachmentReferenceField in customizationItemDbJson && customizationItemDbJson[attachmentReferenceField].length > 0) {
					console.log("Item " + customizationItemDbJson[CUSTOMIZATION_CATEGORY_SPECIFIC_VARS[customizationCategory].CustomizationNameField] + " has attachments. Adding now.");
					wixData.replaceReferences(CUSTOMIZATION_CATEGORY_SPECIFIC_VARS[customizationCategory].CustomizationDb, attachmentReferenceField, item._id, customizationItemDbJson[attachmentReferenceField], options)
						.then(() => {
							console.log("Attachment references added for ", customizationItemDbJson[CUSTOMIZATION_CATEGORY_SPECIFIC_VARS[customizationCategory].CustomizationNameField]);
						})
						.catch((error) => {
							console.error("Error ", error, " occurred when replacing attachment references for ", customizationItemDbJson._id, " in ", KeyConstants.ARMOR_CUSTOMIZATION_DB, 
								" with ", customizationItemDbJson[attachmentReferenceField]);
						});
				}


			})
			.catch((error) => {
				console.error("Error ", error, " occurred when adding this item to DB: ", customizationItemDbArray[i]);
			});
	}
}

// This function is responsible for executing the updateDbsFromApi() function in an orderly, load-balanced fashion (that is also ugly as sin holy crap).
export function updateDbCaller() {
	makeWaypointHeaders()
		.then((headers) => { // Getting the headers once and then using them a bunch is way more efficient than getting them for each request.
			importManufacturers(headers) // We're going to import the manufacturers before anything else. This isn't a super lengthy process, but will take a few seconds.
				.then(() => {
					getGeneralDictsAndArraysFromDbs()
						.then((generalDictsAndArrays) => {
							let customizationCategoryArmor = KeyConstants.ARMOR_KEY;
							updateDbsFromApi(headers, customizationCategoryArmor, ["Cores"], generalDictsAndArrays, null)
								.then((returnCode) => {
									if (!returnCode) { // If we weren't successful in adding the Cores, we probably won't have the necessary information to successfully add items. Might as well be done.
										getCategorySpecificDictsAndArraysFromDbs(customizationCategoryArmor)
											.then((categorySpecificDictsAndArrays) => {
												updateDbsFromApi(headers, customizationCategoryArmor, ["Kits"], generalDictsAndArrays, categorySpecificDictsAndArrays)
													.then((returnCode) => {
														if (!returnCode) { // If we weren't successful in adding the Kits, we probably won't have the necessary information to successfully add items. Might as well be done.
															// This currently offers surprisingly good load balancing. Might need to tweak in future, but damn I'm good.
															updateDbsFromApi(headers, customizationCategoryArmor, ["Coatings"], generalDictsAndArrays, categorySpecificDictsAndArrays)
																.then(() => console.log("Finished adding ", ["Coatings"], " for " + customizationCategoryArmor));
															updateDbsFromApi(headers, customizationCategoryArmor, ["Emblems"], generalDictsAndArrays, categorySpecificDictsAndArrays)
																.then(() => console.log("Finished adding ", ["Emblems"], " for " + customizationCategoryArmor));
															updateDbsFromApi(headers, customizationCategoryArmor, ["Visors", "LeftShoulderPads", "RightShoulderPads", "Gloves", "KneePads"], generalDictsAndArrays, categorySpecificDictsAndArrays)
																.then(() => console.log("Finished adding ", ["Visors", "LeftShoulderPads", "RightShoulderPads", "Gloves", "KneePads"], " for " + customizationCategoryArmor));
															updateDbsFromApi(headers, customizationCategoryArmor, ["Helmets", "ChestAttachments", "WristAttachments", "HipAttachments", "ArmorFx", "MythicFx"], generalDictsAndArrays, categorySpecificDictsAndArrays)
																.then(() => console.log("Finished adding ", ["Helmets", "ChestAttachments", "WristAttachments", "HipAttachments", "ArmorFx", "MythicFx"], " for " + customizationCategoryArmor));
														}
														else {
															console.error("Unable to process Armor items due to failure to add Kits.");
														}
													});
											});
									}
									else {
										console.error("Unable to process Armor items due to failure to add Cores.");
									}
								});
							
							let customizationCategoryWeapon = KeyConstants.WEAPON_KEY;
							updateDbsFromApi(headers, customizationCategoryWeapon, ["Cores"], generalDictsAndArrays, null)
								.then((returnCode) => {
									if (!returnCode) { // If we weren't successful in adding the Cores, we probably won't have the necessary information to successfully add items. Might as well be done.
										getCategorySpecificDictsAndArraysFromDbs(customizationCategoryWeapon)
											.then((categorySpecificDictsAndArrays) => {
												updateDbsFromApi(headers, customizationCategoryWeapon, ["Kits"], generalDictsAndArrays, categorySpecificDictsAndArrays)
													.then((returnCode) => {
														if (!returnCode) { // If we weren't successful in adding the Cores, we probably won't have the necessary information to successfully add items. Might as well be done.
															updateDbsFromApi(headers, customizationCategoryWeapon, ["Coatings"], generalDictsAndArrays, categorySpecificDictsAndArrays)
																.then(() => console.log("Finished adding ", ["Coatings"], " for " + customizationCategoryWeapon));
															updateDbsFromApi(headers, customizationCategoryWeapon, ["Emblems"], generalDictsAndArrays, categorySpecificDictsAndArrays)
																.then(() => console.log("Finished adding ", ["Emblems"], " for " + customizationCategoryWeapon));
															updateDbsFromApi(headers, customizationCategoryWeapon, ["StatTrackers", "WeaponCharms", "AmmoCounterColors", "DeathFx", "AlternateGeometryRegions"], generalDictsAndArrays, categorySpecificDictsAndArrays)
																.then(() => console.log("Finished adding ", ["StatTrackers", "WeaponCharms", "AmmoCounterColors", "DeathFx", "AlternateGeometryRegions"], 
																	" for " + customizationCategoryWeapon));
														}
														else {
															console.error("Unable to process Weapon items due to failure to add Kits.");
														}
													});
											});
									}
									else {
										console.error("Unable to process Weapon items due to failure to add Cores.");
									}
								});

							let customizationCategoryVehicle = KeyConstants.VEHICLE_KEY;
							updateDbsFromApi(headers, customizationCategoryVehicle, ["Cores"], generalDictsAndArrays, null)
								.then((returnCode) => {
									if (!returnCode) { // If we weren't successful in adding the Cores, we probably won't have the necessary information to successfully add items. Might as well be done.
										getCategorySpecificDictsAndArraysFromDbs(customizationCategoryVehicle)
											.then((categorySpecificDictsAndArrays) => {
												updateDbsFromApi(headers, customizationCategoryVehicle, ["Coatings"], generalDictsAndArrays, categorySpecificDictsAndArrays)
													.then(() => console.log("Finished adding ", ["Coatings"], " for " + customizationCategoryVehicle));
												updateDbsFromApi(headers, customizationCategoryVehicle, ["Emblems"], generalDictsAndArrays, categorySpecificDictsAndArrays)
													.then(() => console.log("Finished adding ", ["Emblems"], " for " + customizationCategoryVehicle));
												updateDbsFromApi(headers, customizationCategoryVehicle, ["VehicleFx", "VehicleCharms", "Horns", "AlternateGeometryRegions"], generalDictsAndArrays, categorySpecificDictsAndArrays)
													.then(() => console.log("Finished adding ", ["VehicleFx", "VehicleCharms", "Horns", "AlternateGeometryRegions"], " for " + customizationCategoryVehicle));
											});
									}
									else {
										console.error("Unable to process Vehicle items due to failure to add Cores.");
									}
								});

							let customizationCategoryBodyAndAi = KeyConstants.BODY_AND_AI_KEY;
							getCategorySpecificDictsAndArraysFromDbs(customizationCategoryBodyAndAi)
								.then((categorySpecificDictsAndArrays) => {
									updateDbsFromApi(headers, customizationCategoryBodyAndAi, ["Models", "Colors"], generalDictsAndArrays, categorySpecificDictsAndArrays)
										.then(() => console.log("Finished adding ", ["Models", "Colors"], " for " + customizationCategoryBodyAndAi));
								});

							let customizationCategorySpartanId = KeyConstants.SPARTAN_ID_KEY;
							getCategorySpecificDictsAndArraysFromDbs(customizationCategorySpartanId)
								.then((categorySpecificDictsAndArrays) => {
									updateDbsFromApi(headers, customizationCategorySpartanId, ["ActionPoses", "Emblems", "BackdropImages"], generalDictsAndArrays, categorySpecificDictsAndArrays)
										.then(() => console.log("Finished adding ", ["ActionPoses", "Emblems", "BackdropImages"], " for " + customizationCategorySpartanId));
								});
							
						});
				});
		}); 
	
}

/*export function testSpartanIdImport() {
	makeWaypointHeaders()
		.then((headers) => { // Getting the headers once and then using them a bunch is way more efficient than getting them for each request.
			getGeneralDictsAndArraysFromDbs()
				.then((generalDictsAndArrays) => {
					let customizationCategorySpartanId = KeyConstants.SPARTAN_ID_KEY;
					getCategorySpecificDictsAndArraysFromDbs(customizationCategorySpartanId)
						.then((categorySpecificDictsAndArrays) => {
							updateDbsFromApi(headers, customizationCategorySpartanId, ["ActionPoses", "Emblems", "BackdropImages"], generalDictsAndArrays, categorySpecificDictsAndArrays)
								.then(() => console.log("Finished adding ", ["ActionPoses", "Emblems", "BackdropImages"], " for " + customizationCategorySpartanId));
						});
					
				});
		}); 
}*/

export async function testSave() {
	/*wixData.bulkSave(KeyConstants.ARMOR_CORE_DB, [{"name": "Test1"}])
		.then((results) => {
			console.log(results);
		})
		.catch(error => {
			console.error(error);
		});*/

	/*wixData.query(KeyConstants.ARMOR_CUSTOMIZATION_DB)
		.eq("name", "Test1")
		.find()
		.then((results) => {
			if (results.items.length == 1) {
				let updatedItem = results.items[0];
				updatedItem.name = "Test 2";
				console.log(updatedItem);
				wixData.bulkSave(KeyConstants.ARMOR_CORE_DB, [updatedItem, updatedItem])
					.then((results) => {
						console.log(results);
					})
					.catch(error => {
						console.error(error);
					})
			}
		});*/
	let customizationCategory = "Armor";
	await wixData.query(CUSTOMIZATION_CATEGORY_SPECIFIC_VARS[customizationCategory].CustomizationDb)
		.eq(CUSTOMIZATION_CATEGORY_SPECIFIC_VARS[customizationCategory].CustomizationNameField, "A Tempest of Blades")
		.include("sourceTypeReference")
		.find()
		.then((results) => {
			console.log(results.items[0]);
		})
		.catch ((error) => {
			console.error(error);
			return -1;
		});
}